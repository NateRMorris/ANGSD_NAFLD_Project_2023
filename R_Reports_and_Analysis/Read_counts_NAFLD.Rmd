---
title: "Read Counts"
output: html_document
date: "2023-04-03"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Methods Continued - Differential Gene Expression Analysis

1. Read in the featureCounts summary and graph

```{r}
## For Feature Counts Summary Graph
library(dplyr)
library(data.table)
library(ggplot2)
nafld_fc <- read.table("/Users/johnmorris/Desktop/Comp_Bio_MS_Weill_Cornell/Spring_2023/ANGSD/Project_Download/final_project_scripts/gene_counts_NAFLD_gene_reverse_stranded.summary")
row.names(nafld_fc) <- nafld_fc[,1]
nafld_fc<- nafld_fc[,-1]
nafld_fc[1,] <- c(paste("HIGH", c(1:4), sep = "_"), paste("LOW", c(1:4), sep = "_"))

transposed_second <- data.frame(t(nafld_fc))
transposed_second_new <- transposed_second[, c(1,2,10,13,15)]

long_new <- melt(setDT(transposed_second_new), id.vars = c("Status"))

long_new$value <- as.numeric(long_new$value)
ggplot(data = long_new, aes(x=Status, y = value, fill = variable) ) + geom_bar(stat="identity", position='dodge') + ylab("# reads") + xlab("samples") + coord_flip()
```
As you can see, the feature/read count distribution shows many samples assigned to no features and to multimapping. This is due to the fact that I decided to not assign multi-mapped features (reads that are multiple places on the genome), and our GFF file contains many features. I initially thought was the more features would lead to more assigned features, however this isn't always the case.

2. Reading in featureCounts results

```{r}
# Read in the data
folder <- "/Users/johnmorris/Desktop/Comp_Bio_MS_Weill_Cornell/Spring_2023/ANGSD/Project_Download/final_project_scripts/gene_counts_NAFLD_gene_reverse_stranded" # download count table! ## reading in featureCounts output
readcounts <- read.table(t(folder), header = TRUE)
```

3. Changing the rownames to represent the conditions and replicate names

```{r}
original_names <- names(readcounts)
names(readcounts) <- c(names(readcounts)[1:6],
  "HIGH_1", "HIGH_2", "HIGH_3", "HIGH_4", "LOW_1",
  "LOW_2", "LOW_3", "LOW_4")
#str(readcounts)
```

4. DESeq2 object set up and readcounts assay organization

```{r}
#BiocManager::install("DESeq2")
library(DESeq2)
row.names(readcounts) <- make.names(readcounts$Geneid)

# Eliminate unnecessary rows
readcounts <- readcounts[ , -c(1:6)]
head(readcounts)

## Create sample_info
sample_info <- data.frame(condition = gsub("[0-9]+", "", names(readcounts)),
                         row.names = names(readcounts) )

# Create the DESeq object
DESeq.ds <- DESeqDataSetFromMatrix(countData = as.matrix(readcounts),
                                   colData = sample_info,
                                   design = ~ condition)
DESeq.ds
head(counts(DESeq.ds))

# Check the sums of the reads for each condition
colSums(counts(DESeq.ds))
barplot(colSums(counts(DESeq.ds)), main = "Total Counts", ylab = "Counts #", xlab = "Condition", las = 2)
```
The sum of each replicate and condition matches the total counts we see from the summary featureCounts table, as well as in the QC.


```{r}
# Original dimensions with empty genes
paste0("The original dimensions of the object including empty genes is: ")
dim(DESeq.ds)
```

```{r}
# Pre-filtering low count genes before running DESeq2 functions
library(magrittr)
keep_genes <- rowSums(counts(DESeq.ds)) > 0
DESeq.ds <- DESeq.ds[ keep_genes, ]
paste0("The original dimensions of the object excluding empty genes is: ")
dim(DESeq.ds)
#counts(DESeq.ds) %>% str
#assay(DESeq.ds) %>% str
```

5. Normalizing for sequence depth and RNA composition differences

Raw read counts are strongly influenced by the actual expression level, but they are also impacted by the gene length, transcript sequence (%GC), sequence depth, the expression of all the other genes in the same sample and which method we chose to deal with multimapped reads. Here, we can normalize the samples to minimize the impact of these effects.

```{r}
# Calculate the size factors and add them to the object
DESeq.ds <- estimateSizeFactors(DESeq.ds)
# Assess the size factors
plot(sizeFactors(DESeq.ds), colSums(counts(DESeq.ds)),
      ylab = "library sizes", xlab = "size factors", cex = .6 )
```

```{r}
# Extracting normalized counts
counts.sf_normalized <- counts(DESeq.ds, normalized=TRUE)
# Creating the boxplots to compare normalized vs non-normalized reads
par(mfrow=c(1,2))
boxplot(counts(DESeq.ds), main = "read counts only", cex = .6)
boxplot(counts.sf_normalized, main = "SF normalized", cex = .6)
```
In the above, we can check whether the normalization helped adjust global differences between samples. However, due to the different scales, it is hard to compare. Below, we can see them with similar scales.

```{r}
# Transform the normalized read counts to bring them onto similar scales

# Boxplot of non-normalized
par(mfrow=c(1,2))
boxplot(log2(counts(DESeq.ds) +1), notch=TRUE,
        main = "Non-normalized read counts",
        ylab ="log2(read counts)", cex = .6, las = 2)
# Boxplot of size-factor normalized values
boxplot(log2(counts(DESeq.ds, normalized=TRUE) +1), notch=TRUE,
        main = "Size-factor-normalized read counts",
        ylab ="log2(read counts)", cex = .6, las = 2)
```
As you can see, across the replicates, the size factor normalization of the read counts worked well.

a. Understanding more properties of read count data

```{r}
## Make a scatterplot of log normalized counts against each other to see how well the values correlate within a condition per sample and gene. Here we focus on two samples.

## non-normalized read counts plus pseudocount
log.counts <- log2(counts(DESeq.ds, normalized = FALSE) + 1)
## instead of creating a new object, we could assign the values to a distinct matrix ## within the DESeq.ds object
assay(DESeq.ds, "log.counts") <- log2(counts(DESeq.ds, normalized = FALSE) + 1)
## normalized read counts
assay(DESeq.ds, "log.norm.counts") <- log2(counts(DESeq.ds, normalized=TRUE) + 1)
par(mfrow=c(1,2))
DESeq.ds[, c("HIGH_1","HIGH_2")] %>%
  assay(.,  "log.norm.counts") %>%
  plot(., cex=.1, main = "HIGH_1 vs. HIGH_2")
DESeq.ds[, c("LOW_1","LOW_2")] %>%
  assay(.,  "log.norm.counts") %>%
  plot(., cex=.1, main = "LOW_1 vs LOW_2")
```
These plots comparing the log normalized counts for each gene between each sample and replicate should primarily only fan out at the lower levels, since they should correlate less well at lower expression, and come together at higher levels, since they should correlate more when the values increase. This indicates that the standard deviation of expression levels depends on the mean. However, for the HIGH condition, they don't correlate very well when they are high. For the LOW condition, they seem to correlate better.

```{r, }
#BiocManager::install("vsn")
library(vsn)
library(ggplot2)
```

```{r}
# Generate the base meanSdPlot using sequencing depth normalized log2(read counts)
par(mfrow=c(1,1)) # Setting up the plotting frame
# Generate the plot
msd_plot <- vsn::meanSdPlot(assay(DESeq.ds, "log.norm.counts"), ranks=FALSE, # show the data on the original scale
plot = FALSE)
msd_plot$gg +
  ggtitle("Sequencing depth normalized log2(read counts)") +
  ylab("standard deviation")
```
This depicts that there is a variance-mean dependence with low read counts, or else the red line would be horizontal. The data shows signs of heteroskedasticity (or a non-normal distribution of variances)!

b. Reducing the dependence of the variance on the mean

Rlog is the regularized log function. This transforms the count data to a log2 scale, which minimizes the differences between samples for rows with small counts, and normalized with respect to library size. This is the optimized method for RNA-seq. 

```{r}
## this actually generates a different type of object!
DESeq.rlog <- rlog(DESeq.ds, blind = TRUE)
## set blind = FALSE if the conditions are expected to introduce ## strong differences in a large proportion of the genes
## (blind means blind to the experimental design)
par(mfrow=c(1,2))
plot(assay(DESeq.ds, "log.norm.counts")[,1:2], cex=.1,
     main = "size factor and log2-transformed")
## the rlog-transformed counts are stored in the "assay" accessor
plot(assay(DESeq.rlog)[,1:2],
     cex=.1, main = "rlog transformed",
     xlab = colnames(assay(DESeq.rlog[,1])),
     ylab = colnames(assay(DESeq.rlog[,2])) )
```
The rlog transformed plot seems to show lesser variance across all of the read counts.
```{r}
rlog.norm.counts <- assay(DESeq.rlog)
```

Now, we have expression values that have been adjusted for:
• differences in sequencing depth; 
• differences in RNA composition; 
• heteroskedasticity;
• large dynamic range.

```{r}
## rlog-transformed read counts
msd_plot <- vsn::meanSdPlot(assay(DESeq.rlog), ranks=FALSE, plot = FALSE)
msd_plot$gg + ggtitle("Following rlog transformation") +
  coord_cartesian(ylim = c(0,3))
```

Looks a lot better!

Save for future uses:

```{r}
#save.image(file = "/Users/johnmorris/Desktop/Comp_Bio_MS_Weill_Cornell/Spring_2023/ANGSD/Project_Download/ANGSD_NAFLD_Project_2023/Datasets/NAFLD_BulkRNA.RData")
```

4. Running the Differential Gene Expression Analysis

```{r}
library(magrittr)
library(DESeq2)

FILE_DSD="/Users/johnmorris/Desktop/Comp_Bio_MS_Weill_Cornell/Spring_2023/ANGSD/Project_Download/ANGSD_NAFLD_Project_2023/Datasets/NAFLD_BulkRNA.RData"
load(FILE_DSD)
DESeq.ds
DESeq.ds$condition
DESeq.ds$condition <- relevel(DESeq.ds$condition, ref = "LOW_") #Relevel to set the reference level to low
design(DESeq.ds)
# We also have DESeq.rlog

```

````{r}
DESeq.ds %<>% DESeq()

# The above line is equivalent to:
# normalize for diffs in sequencing depth and abundance per sample
# DESeq.ds %<>% estimateSizeFactors()
# gene-wise dispersion estimates across all samples
# DESeq.ds %<>% estimateDispersions()
# fit a neg. binomial GLM and compute Wald stat for each gene 
# DESeq.ds %<>% nbinomWaldTest()

# Now the DESeq object has additional entries in the rowdata column
DESeq.ds
rowData(DESeq.ds) %>% colnames
```

5. Adjusting for multiple hypothesis testing with independent filtering

As we can see, the raw p-values allow for genes that have very low read counts. This can affect our p-values, since gene with low read counts can be too unreliable and variable, and therefore have very large p-values. It is important to remove them before the multiple testing adjustments. The results() function of DESeq2 will try to find the optimal expression cut-off to maximize the number of genes that pass the adjusted p-value threshold. For genes with low reads, p-adj will be filled with NA.
```{r}
 rowData(DESeq.ds)$WaldPvalue_condition_HIGH__vs_LOW_ %>%
    hist(breaks=19, main="Raw p-values for LOW vs HIGH")
```
```{r}
DGE.results <- results(DESeq.ds, independentFiltering = TRUE, alpha = 0.05)
# the first line will tell you which comparison was done to achieve the log2FC 
head(DGE.results)
summary(DGE.results)
```
```{r}
DGE.results$padj %>%
    hist(breaks=19, main="Adjusted p-values for HIGH vs LOW")
```
```{r}
DGE.results.sorted <- DGE.results %>% `[`(order(.$padj),)
head(DGE.results.sorted)
```

By looking at the first 6 genes that have the lowest padj values, we can see what these genes correlate to and if the analysis makes sense.

The below make some sense:
RAB7B is a GTPase that plays a role in the transport and degradation of proteins in endosomes and lysosomes in mammalian cells. 
CD52 is associated with the metabolism of proteins pathway and post-transcriptional modification. However, it seems to play a major role in T-cell/immunological function.

However, I haven't been able to find any relation with the below:
WNT4 promotes female sex development and repressess male development. Perhaps this is skewed/bias by the samples I chose?
AKIRIN1 is involved in skeletal muscle development.
PDZK1IP1 is a protein coding gene associated with spinal muscular atrophy and supreglottis neoplasm.
GPR88 is a brain orphan G protein couple receptor, and aids in the striatum development (brain section for motor and reward systems).


ARPC5 is shown in some literature to have a larger affect. And it seems consistent with this study. ARPC5 encodes one of the subunits of the human Arp2/3 protein complex, which plays a large role in the regulation of the actin cytoskeleton.

```{r}
par(mfrow=c(1,2))
#plotCounts(DESeq.ds, gene="ARPC5", normalized = TRUE, xlab="")
plotCounts(DESeq.ds, gene="GPX2", normalized = TRUE, xlab="")
plotCounts(DESeq.ds, gene = which.max(DGE.results$padj), xlab="",
           main = "Gene with max. p.adj.\n(=least significant)")
```

Unfortunately, by plotting the MA, you can see that there aren't really many strongly differentiated genes.

```{r}
plotMA(DGE.results, alpha=0.05,
      main="Test: p.adj.value < 0.05", ylim = c(-8,8))
```

```{r}
#BiocManager::install("EnhancedVolcano")
library(EnhancedVolcano)
vp1 <- EnhancedVolcano(DGE.results,
                       lab=rownames(DGE.results),
                      x='log2FoldChange', y='padj',
                      pCutoff=0.05,
                      title="HIGH / LOW")
print(vp1)
```
Perhaps I need to set the baseline to the LOW condition and the experimental to the HIGH condition?

Here is my attempt at a PCA. However, it seems to categorize them not by gene, but by the conditional group. Therefore, it shows which group is most responsible for each of the outcomes.
```{r}
library(ggplot2)
#pca_data <- plotPCA(rlog(DESeq.ds), intgroup="condition", returnData=TRUE)
plotPCA(rlog(DESeq.ds), intgroup="condition")
```

```{r}
# BiocManager::install("pheatmap")
library(pheatmap)
# identify genes with the desired adjusted p-value cut-off
DGEgenes <- rownames(subset(DGE.results.sorted, padj < 0.05)) # extract rlog-transformed values into a matrix
rlog.dge <- DESeq.rlog[DGEgenes,] %>% assay
# heatmap of DEG sorted by p.adjust
pheatmap(rlog.dge, scale="none",
         show_rownames=FALSE, main="DGE (no scaling)",
         color=colorRampPalette(RColorBrewer::brewer.pal(n=7, name="Reds"))(100)
)
pheatmap(rlog.dge, scale="row",
         show_rownames=FALSE, main="DGE (row-based z-score)")
```



# Running GO or cluster profiler
```{r}
library(magrittr)
library(dplyr)
#load("/Users/johnmorris/Desktop/Comp_Bio_MS_Weill_Cornell/Spring_2023/ANGSD/Project_Download/ANGSD_NAFLD_Project_2023/Datasets/NAFLD_BulkRNA.RData")
# Constructing a named vector of 0 (= not DE) and 1 (= DEG) 
DGE.genes <- rownames(subset(DGE.results.sorted, padj < 0.05))
gene.vector <- row.names(DGE.results.sorted) %in% DGE.genes %>% as.integer
names(gene.vector) <- row.names(DGE.results.sorted)
```

```{r}
library(goseq)
#BiocManager::install("TxDb.Hsapiens.UCSC.hg38.knownGene")
#library(TxDb.Hsapiens.UCSC.hg38.knownGene)
#BiocManager::install("TxDb.Hsapiens.UCSC.hg19.knownGene")
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
library(TxDb.Scerevisiae.UCSC.sacCer3.sgdGene)
pwf <- nullp(gene.vector, "hg19", "knownGene")
```

```{r}
# Using ClusterProfiler for GSEA 
#BiocManager::install("clusterProfiler")
library(clusterProfiler)
#BiocManager::install("org.Hs.eg.db")
library(org.Hs.eg.db)
library(AnnotationDbi)

Gff2GeneTable("/Users/johnmorris/Desktop/Comp_Bio_MS_Weill_Cornell/Spring_2023/ANGSD/Project_Download/genomic.gff", compress = TRUE)
```

```{r}
enricher(gene.vector, pvalueCutoff = 0.05, pAdjustMethod = "bonferroni", minGSSize = 10, maxGSSize = 500, qvalueCutoff = 0.2, TERM2GENE)
download_KEGG(hg38, keggType = "KEGG", keyType = "kegg")

# FOR KEGG ENRICHMENT
# https://www.genome.jp/kegg/catalog/org_list.html
# Convert SYMBOLS in gene.vector to ENTREZIDs - 4.01% failed to map
# Shows that ENTREZIDs are not allowed within enrichKEGG function - https://www.biostars.org/p/204939/
entrez_ids <- bitr(names(which(gene.vector ==1)), fromType = "SYMBOL", toType = "ENTREZID", OrgDb = "org.Hs.eg.db") 

# Use mapIds to convert the SYMBOLs where gene.vector == 1 (where ()) to UNIPROT
uniprot_ids_1 <- mapIds(org.Hs.eg.db, keys = names(which(gene.vector == 1)), column = "UNIPROT", keytype = "SYMBOL")

# Use the enrichKEGG to find the KEGG pathways where the uniprot genes are 
kegg_enrichment <- enrichKEGG(gene = uniprot_ids_1, organism = "hsa", keyType = "uniprot")

# view the top 10 enriched pathways
head(kegg_enrichment@result$Description, n = 10)
#head(kegg_enrichment@result, n = 10)


# FOR GO_ENRICHMENT
BP_go_enrichment <- enrichGO(gene = names(which(gene.vector ==1)), 
                          'org.Hs.eg.db', 
                          keyType = "SYMBOL", # ENTREZ ID NOT SUPPORTED
                          ont = "BP", 
                          pvalueCutoff = 0.01, 
                          qvalueCutoff = 0.05)

head(BP_go_enrichment@result$Description, n = 10)

MF_go_enrichment <- enrichGO(gene = names(which(gene.vector ==1)), 
                          'org.Hs.eg.db', 
                          keyType = "SYMBOL", # ENTREZ ID NOT SUPPORTED
                          ont = "MF", 
                          pvalueCutoff = 0.01, 
                          qvalueCutoff = 0.05)

head(MF_go_enrichment@result$Description, n = 10)

CC_go_enrichment <- enrichGO(gene = names(which(gene.vector ==1)), 
                          'org.Hs.eg.db', 
                          keyType = "SYMBOL", # ENTREZ ID NOT SUPPORTED
                          ont = "CC", 
                          pvalueCutoff = 0.01, 
                          qvalueCutoff = 0.05)

head(CC_go_enrichment@result$Description, n = 10)

GSEA(names(which(gene.vector == 1)))
```

```{r}
# Other Links
# ClusterProfiler - https://www.rdocumentation.org/packages/clusterProfiler/versions/3.0.4
# ClusterProfiler - http://bioconductor.org/packages/release/bioc/manuals/clusterProfiler/man/clusterProfiler.pdf
# USCS hg38 knowngene package - https://bioconductor.org/packages/release/data/annotation/manuals/TxDb.Hsapiens.UCSC.hg38.knownGene/man/TxDb.Hsapiens.UCSC.hg38.knownGene.pdf
# org.HS.eg.db - https://www.bioconductor.org/packages/release/data/annotation/html/org.Hs.eg.db.html

# Go-seq - https://bioconductor.org/packages/devel/bioc/manuals/goseq/man/goseq.pdf

# https://www.ncbi.nlm.nih.gov/assembly/GCF_000001405.40/ - Genome Assembly

# https://bioconductor.org/packages/release/bioc/html/AnnotationHub.html - Annotation HUB

```
