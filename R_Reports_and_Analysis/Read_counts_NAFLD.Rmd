---
title: "Read Counts"
output: html_document
date: "2023-04-03"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Methods Continued - Differential Gene Expression Analysis

1. Read in the featureCounts summary and graph

```{r}
## For Feature Counts Summary Graph
library(dplyr)
library(data.table)
library(ggplot2)
nafld_fc <- read.table("/Users/johnmorris/Desktop/Comp_Bio_MS_Weill_Cornell/Spring_2023/ANGSD/Project_Download/final_project_scripts/gene_counts_NAFLD_gene_reverse_stranded.summary")
row.names(nafld_fc) <- nafld_fc[,1]
nafld_fc<- nafld_fc[,-1]
nafld_fc[1,] <- c(paste("HIGH", c(1:4), sep = "_"), paste("LOW", c(1:4), sep = "_"))

transposed_second <- data.frame(t(nafld_fc))
transposed_second_new <- transposed_second[, c(1,2,10,13,15)]

long_new <- melt(setDT(transposed_second_new), id.vars = c("Status"))

long_new$value <- as.numeric(long_new$value)
ggplot(data = long_new, aes(x=Status, y = value, fill = variable) ) + geom_bar(stat="identity", position='dodge') + ylab("# reads") + xlab("samples") + coord_flip()
```
As you can see, the feature/read count distribution shows many samples assigned to no features and to multimapping. This is due to the fact that I decided to not assign multi-mapped features (reads that are multiple places on the genome), and our GFF file contains many features. I initially thought was the more features would lead to more assigned features, however this isn't always the case.

2. Reading in featureCounts results

```{r}
# Read in the data
folder <- "/Users/johnmorris/Desktop/Comp_Bio_MS_Weill_Cornell/Spring_2023/ANGSD/Project_Download/final_project_scripts/gene_counts_NAFLD_gene_reverse_stranded" # download count table! ## reading in featureCounts output
readcounts <- read.table(t(folder), header = TRUE)
length(rownames(readcounts)) # Here you can see that we have a total of 49306 genes
```

3. Changing the rownames to represent the conditions and replicate names

```{r}
original_names <- names(readcounts)
names(readcounts) <- c(names(readcounts)[1:6],
  "HIGH_1", "HIGH_2", "HIGH_3", "HIGH_4", "LOW_1",
  "LOW_2", "LOW_3", "LOW_4")
#str(readcounts)
```

4. DESeq2 object set up and readcounts assay organization

```{r}
#BiocManager::install("DESeq2")
library(DESeq2)
row.names(readcounts) <- make.names(readcounts$Geneid)

# Eliminate unnecessary rows
readcounts <- readcounts[ , -c(1:6)]
head(readcounts)

## Create sample_info
sample_info <- data.frame(condition = gsub("[0-9]+", "", names(readcounts)),
                         row.names = names(readcounts) )

# Create the DESeq object
DESeq.ds <- DESeqDataSetFromMatrix(countData = as.matrix(readcounts),
                                   colData = sample_info,
                                   design = ~ condition)
DESeq.ds
head(counts(DESeq.ds))

# Check the sums of the reads for each condition
colSums(counts(DESeq.ds))
barplot(colSums(counts(DESeq.ds)), main = "Total Counts", ylab = "Counts #", xlab = "Condition", las = 2)
```
The sum of each replicate and condition matches the total counts we see from the summary featureCounts table, as well as in the QC.


```{r}
# Original dimensions with empty genes
paste0("The original dimensions of the object including empty genes is: ")
dim(DESeq.ds)
```

```{r}
# Pre-filtering low count genes before running DESeq2 functions
library(magrittr)
keep_genes <- rowSums(counts(DESeq.ds)) > 0
DESeq.ds <- DESeq.ds[ keep_genes, ]
paste0("The original dimensions of the object excluding empty genes is: ")
dim(DESeq.ds)
#counts(DESeq.ds) %>% str
#assay(DESeq.ds) %>% str
```

5. Normalizing for sequence depth and RNA composition differences

Raw read counts are strongly influenced by the actual expression level, but they are also impacted by the gene length, transcript sequence (%GC), sequence depth, the expression of all the other genes in the same sample and which method we chose to deal with multimapped reads. Here, we can normalize the samples to minimize the impact of these effects.

```{r}
# Calculate the size factors and add them to the object
DESeq.ds <- estimateSizeFactors(DESeq.ds)
# Assess the size factors
plot(sizeFactors(DESeq.ds), colSums(counts(DESeq.ds)),
      ylab = "library sizes", xlab = "size factors", cex = .6 )
```

```{r}
# Extracting normalized counts
counts.sf_normalized <- counts(DESeq.ds, normalized=TRUE)
# Creating the boxplots to compare normalized vs non-normalized reads
par(mfrow=c(1,2))
boxplot(counts(DESeq.ds), main = "read counts only", cex = .6)
boxplot(counts.sf_normalized, main = "SF normalized", cex = .6)
```
In the above, we can check whether the normalization helped adjust global differences between samples. However, due to the different scales, it is hard to compare. Below, we can see them with similar scales by log2 transforming the counts.

```{r}
# Transform the normalized read counts to bring them onto similar scales

# Boxplot of non-normalized
par(mfrow=c(1,2))
boxplot(log2(counts(DESeq.ds) +1), notch=TRUE,
        main = "Non-normalized read counts",
        ylab ="log2(read counts)", cex = .6, las = 2)
# Boxplot of size-factor normalized values
boxplot(log2(counts(DESeq.ds, normalized=TRUE) +1), notch=TRUE,
        main = "Size-factor-normalized read counts",
        ylab ="log2(read counts)", cex = .6, las = 2)
```
As you can see, across the replicates, the size factor normalization of the read counts worked well.

a. Understanding more properties of read count data

```{r}
## Make a scatterplot of log normalized counts against each other to see how well the values correlate within a condition per sample and gene. Here we focus on two samples.

## non-normalized read counts plus pseudocount
log.counts <- log2(counts(DESeq.ds, normalized = FALSE) + 1)
## instead of creating a new object, we could assign the values to a distinct matrix ## within the DESeq.ds object
assay(DESeq.ds, "log.counts") <- log2(counts(DESeq.ds, normalized = FALSE) + 1)
## normalized read counts
assay(DESeq.ds, "log.norm.counts") <- log2(counts(DESeq.ds, normalized=TRUE) + 1)
par(mfrow=c(1,2))
DESeq.ds[, c("HIGH_1","HIGH_2")] %>%
  assay(.,  "log.norm.counts") %>%
  plot(., cex=.1, main = "HIGH_1 vs. HIGH_2")
DESeq.ds[, c("LOW_1","LOW_2")] %>%
  assay(.,  "log.norm.counts") %>%
  plot(., cex=.1, main = "LOW_1 vs LOW_2")
```
These plots comparing the log normalized counts for each gene between each sample and replicate should primarily only fan out at the lower levels, since they should correlate less well at lower expression, and come together at higher levels, since they should correlate more when the values increase. This indicates that the standard deviation of expression levels depends on the mean. However, for the HIGH condition, they don't correlate very well when they are high. For the LOW condition, they seem to correlate better.

```{r, }
#BiocManager::install("vsn")
library(vsn)
library(ggplot2)
```

```{r}
# Generate the base meanSdPlot using sequencing depth normalized log2(read counts)
par(mfrow=c(1,1)) # Setting up the plotting frame
# Generate the plot
msd_plot <- vsn::meanSdPlot(assay(DESeq.ds, "log.norm.counts"), ranks=FALSE, # show the data on the original scale
plot = FALSE)
msd_plot$gg +
  ggtitle("Sequencing depth normalized log2(read counts)") +
  ylab("standard deviation")
```
This depicts that there is a variance-mean dependence with low read counts, or else the red line would be horizontal. The data shows signs of heteroskedasticity (or a non-normal distribution of variances)!

b. Reducing the dependence of the variance on the mean

Rlog is the regularized log function. This shrinks the count data to a log2 scale, which minimizes the differences between samples for rows with small counts, and normalizes with respect to library size. Therefore, this allows us to base the variability of the genes on the overall average expression between all genes since it assumes that all genes that share similar average expression values should also display similar noise levels. This is the optimized method for RNA-seq. 

```{r}
DESeq.rlog <- rlog(DESeq.ds, blind = TRUE)
# Blind is set to TRUE because we want our results to be blind to the experimental design. This is because our null hypothesis is expecting there to not be any difference in the genes between the two conditions
par(mfrow=c(1,2))
plot(assay(DESeq.ds, "log.norm.counts")[,1:2], cex=.1,
     main = "size factor and log2-transformed")

## the rlog-transformed counts are stored in the "assay" accessor
plot(assay(DESeq.rlog)[,1:2],
     cex=.1, main = "rlog transformed",
     xlab = colnames(assay(DESeq.rlog[,1])),
     ylab = colnames(assay(DESeq.rlog[,2])) )
```
The rlog transformed plot seems to show lesser variance across all of the read counts.

We can set our rlog, normalized counts as the DESeq rlog assay.
```{r}
rlog.norm.counts <- assay(DESeq.rlog)
```

Now, we have expression values that have been adjusted for:
• differences in sequencing depth; 
• differences in RNA composition; 
• heteroskedasticity;
• large dynamic range.

```{r}
## rlog-transformed read counts
msd_plot <- vsn::meanSdPlot(assay(DESeq.rlog), ranks=FALSE, plot = FALSE)
msd_plot$gg + ggtitle("Following rlog transformation") +
  coord_cartesian(ylim = c(0,3))
```

Looks a lot better!

Save for future uses:

```{r}
#save.image(file = "/Users/johnmorris/Desktop/Comp_Bio_MS_Weill_Cornell/Spring_2023/ANGSD/Project_Download/ANGSD_NAFLD_Project_2023/Datasets/NAFLD_BulkRNA.RData")
```

4. Running the Differential Gene Expression Analysis

```{r}
library(magrittr)
library(DESeq2)

FILE_DSD="/Users/johnmorris/Desktop/Comp_Bio_MS_Weill_Cornell/Spring_2023/ANGSD/Project_Download/ANGSD_NAFLD_Project_2023/Datasets/NAFLD_BulkRNA.RData"
load(FILE_DSD)
DESeq.ds
DESeq.ds$condition
DESeq.ds$condition <- relevel(DESeq.ds$condition, ref = "LOW_") #Relevel to set the reference level to low
design(DESeq.ds)
# We also have DESeq.rlog

```

````{r}
DESeq.ds %<>% DESeq()

# The above line is equivalent to:
# normalize for diffs in sequencing depth and abundance per sample
# DESeq.ds %<>% estimateSizeFactors()
# gene-wise dispersion estimates across all samples
# DESeq.ds %<>% estimateDispersions()
# fit a neg. binomial GLM and compute Wald stat for each gene 
# DESeq.ds %<>% nbinomWaldTest()

# Now the DESeq object has additional entries in the rowdata column
DESeq.ds
rowData(DESeq.ds) %>% colnames
```

5. Adjusting for multiple hypothesis testing with independent filtering

When performing a large number of tests, p-values have a higher probability of representing a false positive outcome rather than a true positive outcome. For this reason, it is important to adjust the p-values, called multiple testing correction.

Before multiple testing correction, it is important to ignore genes with low read counts as we can't make assessments on their gene expression because the counts can be too unreliable and variable. The results() function of DESeq2 will try to find the optimal expression cut-off to maximize the number of genes that pass the adjusted p-value threshold. For genes with low reads, p-adj will be filled with NA.

```{r}
 rowData(DESeq.ds)$WaldPvalue_condition_HIGH__vs_LOW_ %>%
    hist(breaks=19, main="Raw p-values for LOW vs HIGH")
```

```{r}
DGE.results <- results(DESeq.ds, independentFiltering = TRUE, alpha = 0.05)
# Set independent filtering as true to apply the results function and ignore genes with low expression levels (NA p-adj value)
head(DGE.results)
summary(DGE.results)
table(DGE.results$padj < 0.05)
```

6. Assessing the DE results

```{r}
DGE.results$padj %>%
    hist(breaks=19, main="Adjusted p-values for HIGH vs LOW")
```
The results from the adjust p-values to indicate that there are 1897 genes that have values less than 0.05, as shown in the table previously. However, as you can see, there is also a high frequency of genes at other p-adj values. 

```{r}
DGE.results.sorted <- DGE.results %>% `[`(order(.$padj),)
head(DGE.results.sorted)
```
By looking at the first 6 genes that have the lowest p-adj values, we can see what these genes correlate to and if the analysis makes sense.

GPX2 encodes for a protein in the glutathione peroxidase family. It helps catalyze the reduction of organic hydroperoxides and hydrogen peroxide. It is present in the gastrointestinal tract and liver in humans. Overexpression of this gene is associated with increased differentiation and proliferation in gastrointestinal cancer (https://www.genecards.org/cgi-bin/carddisp.pl?gene=GPX2). It is relates to the fatty acid metabolism and glutathione conjugation pathways.

AKR1B10 is a member of the aldo-keto reductase family and encodes for a protein that catalyzes the NADPH-dependent reduction of a wide variety of carbonyl-containing compounds. It is involved in the cyclophosphamide pathway/pharmacodynamics (https://www.genecards.org/cgi-bin/carddisp.pl?gene=AKR1B10) and may play an important role in liver carcinogenesis.

LOC124909347 and LINC01322 are associated with the non-coding RNA class. As you can see, the baseMean or expression value is considerably lower than the first two genes (https://www.genecards.org/cgi-bin/carddisp.pl?gene=LOC124909347, https://www.genecards.org/cgi-bin/carddisp.pl?gene=LINC01322).

PROZ encodes for a liver vitamin K-dependent glycoprotein that plays a role in regulating blood coagulation (https://www.genecards.org/cgi-bin/carddisp.pl?gene=PROZ).

LDL encodes for lipoprotein lipase, a key enzyme in triglyceride metabolism. Mutations are linked to many disorders of lipoprotein metabolism (https://www.genecards.org/cgi-bin/carddisp.pl?gene=LPL).

ARPC5 is shown in some literature to have a larger affect. And it seems consistent with this study. ARPC5 encodes one of the subunits of the human Arp2/3 protein complex, which plays a large role in the regulation of the actin cytoskeleton.

```{r}
par(mfrow=c(1,2))
plotCounts(DESeq.ds, gene="TES", normalized = TRUE, xlab="")
#plotCounts(DESeq.ds, gene="GPX2", normalized = TRUE, xlab="")
plotCounts(DESeq.ds, gene = which.max(DGE.results$padj), xlab="",
           main = "Gene with max. p.adj.\n(=least significant)")
```

Volcano Plot

```{r}
#BiocManager::install("EnhancedVolcano")
library(EnhancedVolcano)
vp1 <- EnhancedVolcano(DGE.results,
                       lab=rownames(DGE.results),
                      x='log2FoldChange', y='padj',
                      pCutoff=0.05,
                      title="HIGH / LOW")
print(vp1)
```
The volcano plot allows you to see the 


MA Plot
```{r}
plotMA(DGE.results, alpha=0.05,
      main="Test: p.adj.value < 0.05", ylim = c(-8,8))
```
In the MA plot, each point represents a single gene, and the x axis shows the mean normalized counts for that gene, and the y axis represents the log fold change of that gene. Genes that are passing the significance threshold (the adjusted p-value is < 0.05 for this experiment) are colored in blue. As you can see, the differentially expressed genes aincrease as you increase the expression. Although, there is higher log fold change of genes at lower expression levels.

PCA Plot
```{r}
library(ggplot2)
#pca_data <- plotPCA(rlog(DESeq.ds), intgroup="condition", returnData=TRUE)
plotPCA(rlog(DESeq.ds), intgroup="condition") + geom_text(aes(label = colnames(DESeq.ds)), size = 3, hjust = 0, vjust = 0)
```
The PCA plot shows the reduces dimensionality of the dataset, while preserving the majority of the variation in the data. PC1 accounts for 47% of the variance in the dataset, and based on this, the LOW and the HIGH groups seem generally separated, however they are not totally distinct. LOW_3 and HIGH_3 seem to be overlapping in PC1, but separated heavily in PC2. In PC2, HIGH_2 is somewhat of an outlier, as it doesn't group with the other HIGH condition samples. There isn't drastic differences in these groups, and the clustering in the PCA isn't very promising. However, this could be due primarily to the variability of the disease.

Heatmap of DEG sorted by the adjusted p-values.
```{r}
# BiocManager::install("pheatmap")
library(pheatmap)
# identify genes with the desired adjusted p-value cut-off of 0.05
DGEgenes <- rownames(subset(DGE.results.sorted, padj < 0.05)) # extract rlog-transformed values into a matrix
rlog.dge <- DESeq.rlog[DGEgenes,] %>% assay
# Heatmap of DEG sorted by p.adjust
#pheatmap(rlog.dge, scale="none",
#         show_rownames=FALSE, main="DGE (no scaling)",
#         color=colorRampPalette(RColorBrewer::brewer.pal(n=7, name="Reds"))(100)
#)
pheatmap(rlog.dge, scale="row",
         show_rownames=FALSE, main="DGE (row-based z-score)")
```
This heat map can be used to visualize the distribution and relative intensity of the z-scores for each gene for each replicate within each condition. The z-score tells us how many standard deviations the particular point is from the mean of the dataset. Here, each row represents a gene in each sample, and it's z-score. The trend shown here is that the top portion of the genes are down-regulated, and therefore have negative z-scores and are lower expression than the mean, for the HIGH condition samples, they are up-regulated for the LOW condition samples. The opposite can be said for the bottom portion of the genes. Based on this information, HIGH_2 seems to express some genes considerably more or less than the replicates. HIGH_3 seems to not express as much as the other samples within it's condition are. I believe the variability of the disease can cause these variations, but perhaps if we had more data, we could exclude certain samples as outliers.


# Running GO or cluster profiler
```{r}
library(magrittr)
library(dplyr)
#load("/Users/johnmorris/Desktop/Comp_Bio_MS_Weill_Cornell/Spring_2023/ANGSD/Project_Download/ANGSD_NAFLD_Project_2023/Datasets/NAFLD_BulkRNA.RData")
# Constructing a named vector of 0 (= not DE) and 1 (= DEG) 
DGE.genes <- rownames(subset(DGE.results.sorted, padj < 0.05))
#DGE.genes <- rownames(subset(DGE.results.sorted, padj < 0.05 & abs(log2FoldChange) >= 1.5 ))
gene.vector <- row.names(DGE.results.sorted) %in% DGE.genes %>% as.integer
names(gene.vector) <- row.names(DGE.results.sorted)

# Confirming that there are 1897 genes that are differential expressed:
length(which(DGE.results$padj < 0.05))
length(which(gene.vector ==1))
```

```{r}
# Using ClusterProfiler for GSEA 
#BiocManager::install("clusterProfiler")
library(clusterProfiler)
#BiocManager::install("org.Hs.eg.db")
library(org.Hs.eg.db)
##BiocManager::install("AnnotationDbi")
library(AnnotationDbi)
#BiocManager::install("TxDb.Hsapiens.UCSC.hg38.knownGene")
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
#BiocManager::install("TxDb.Hsapiens.UCSC.hg19.knownGene")
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
#enricher(gene.vector, pvalueCutoff = 0.05, pAdjustMethod = "bonferroni", minGSSize = 10, maxGSSize = 500, qvalueCutoff = 0.2, TERM2GENE)
#download_KEGG(hg38, keggType = "KEGG", keyType = "kegg")

# FOR KEGG ENRICHMENT
# https://www.genome.jp/kegg/catalog/org_list.html
# Convert SYMBOLS in gene.vector to ENTREZIDs - 4.01% failed to map
# Shows that ENTREZIDs are not allowed within enrichKEGG function - https://www.biostars.org/p/204939/
entrez_ids <- bitr(names(which(gene.vector ==1)), fromType = "SYMBOL", toType = "ENTREZID", OrgDb = "org.Hs.eg.db") 

# Use mapIds to convert the SYMBOLs where gene.vector == 1 (where ()) to UNIPROT
uniprot_ids_1 <- mapIds(org.Hs.eg.db, keys = names(which(gene.vector == 1)), column = "UNIPROT", keytype = "SYMBOL")

# Use the enrichKEGG to find the KEGG pathways where the uniprot genes are 
kegg_enrichment <- enrichKEGG(gene = uniprot_ids_1, organism = "hsa", keyType = "uniprot")

# view the top 10 enriched pathways
head(kegg_enrichment@result$Description, n = 10)
#head(kegg_enrichment@result, n = 10)


# FOR GO_ENRICHMENT
BP_go_enrichment <- enrichGO(gene = names(which(gene.vector ==1)), 
                          'org.Hs.eg.db', 
                          keyType = "SYMBOL", # ENTREZ ID NOT SUPPORTED
                          ont = "BP", 
                          pvalueCutoff = 0.01, 
                          qvalueCutoff = 0.05)

head(BP_go_enrichment@result$Description, n = 10)

MF_go_enrichment <- enrichGO(gene = names(which(gene.vector ==1)), 
                          'org.Hs.eg.db', 
                          keyType = "SYMBOL", # ENTREZ ID NOT SUPPORTED
                          ont = "MF", 
                          pvalueCutoff = 0.01, 
                          qvalueCutoff = 0.05)

head(MF_go_enrichment@result$Description, n = 10)

CC_go_enrichment <- enrichGO(gene = names(which(gene.vector ==1)), 
                          'org.Hs.eg.db', 
                          keyType = "SYMBOL", # ENTREZ ID NOT SUPPORTED
                          ont = "CC", 
                          pvalueCutoff = 0.01, 
                          qvalueCutoff = 0.05)

head(CC_go_enrichment@result$Description, n = 10)
```

```{r}
# Hypothesis:
# Immune cell infiltration in NAFLD
'TES' %in% names(gene.vector)
which(names(gene.vector) == "TES")
'CEBPD' %in% names(gene.vector)
which(names(gene.vector) == "CEBPD")
'H4C11' %in% names(gene.vector)
which(names(gene.vector) == "H4C11")
'CEBPB' %in% names(gene.vector)
which(names(gene.vector) == "CEPBP")
'GATA3' %in% names(gene.vector)
which(names(gene.vector) == "GATA3")
'KLF4' %in% names(gene.vector)
which(names(gene.vector) == "KLF4")

# Redox reactions - Metabolic function
'ALDH2' %in% names(gene.vector)
which(names(gene.vector) == "ALDH2")
'ALDH8A1' %in% names(gene.vector)
which(names(gene.vector) == "ALDH8A1")
```




```{r pressure, echo=FALSE}
plot(pressure)
```