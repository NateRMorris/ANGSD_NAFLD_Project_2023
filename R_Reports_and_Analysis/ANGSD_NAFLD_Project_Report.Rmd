---
title: "ANGSD_NAFLD_Project_Nathan_Morris"
output: 
  html_document:
    toc: true
date: "2023-03-29"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# I. Introduction

Non-alcoholic fatty liver disease (NAFLD) is a condition characterized by the accumulation of excess fat in the liver when the individuals consume little to no alcohol. This is a growing health problem and it is estimated that 100 million individuals in the United States have NAFLD (Rivera, 2022) with annual medical costs of about $103 billion (Younossi et al, 2016). NAFLD is the most common form of liver disease in children and it's prevalence has doubled in the past 20 years. Models predict the occurrence of NAFLD cases to increase 21% by 2030 (Estes et al, 2018). The disease is highly associated with obesity, type 2 diabetes and metabolic syndrome. The more severe forms of NAFLD can lead to liver fibrosis, cirrhosis and even liver cancer. The root cause of NAFLD is not known, but environmental, lifestyle and genetic factors are thought to have an effect. High-fat diet, sedentary behavior and insulin resistance are possible causes, and therefore lifestyle changes such as weight loss, exercise and a healthy diet are ways to prevent and treat NAFLD (Rivera, 2022). NAFLD is primarily diagnosed through blood tests, which can show high levels of liver enzymes, however the severity of the condition is defined by the histological examination of liver biopsies. 

Research studies have shown that there are many different pathways responsible for the histological manifestations of the disease activity (such as metabolic, cell stress, death, inflammatory and fibrogenic pathways) (Hoang et al, 2019). Certain studies have found that there is significant down-regulation of genes associated with metabolic processes and significant up-regulation of genes involved in immune responses (Han et al, 2022 and Cao et al, 2023). Immune cell infiltration is an important process that contributes to the development and progression of NAFLD, because the accumulation of fat in the liver leads to inflammation and damage to liver cells, and in response, the immune cells are recruited to remove damaged cells and initiate tissue repair. However, the cytokines released from immune cells can also lead to further liver damage, fibrosis and disease progression (Tilg et al. 2010) leading to metabolic stress, increased reactive oxygen species and increased redox reactions. Therefore, when comparing individuals with severe cases of NAFLD to those with mild cases of NAFLD, I would expect genes CEBPD, H4C11, CEBPB, GATA3 and KLF4 to be upregulated as they are associated with immune cell infiltration in NAFLD and I would also expect upregulation of the genes CAT, ALDH2 and ALDH8A1, which are associated with redox reactions. 


# II. Results:

The present study investigated the gene expression patterns in non-alcoholic fatty liver disease (NAFLD). Based on previous research, we hypothesized that genes CEBPD, H4C11, CEBPB, GATA3, and KLF4, which are associated with immune cell infiltration, would be upregulated in NAFLD. Similarly, we hypothesized that the genes CAT, ALDH2, and ALDH8A1, which are associated with redox reactions, would also be upregulated in NAFLD. However, our results showed that these genes were not upregulated when comparing samples from individuals with severe NAFLD compared to low disease level individuals. 

This conclusion is supported by the list of differential genes, as well as the volcano plot, MA plot, and counts plots, where significant differential expression is not clear. The heat map does show some difference in gene expression between the two conditions, however, the difference between the replicates in each condition could be the cause of this seemingly different gene expression.

Our pathway analysis shows us that immune cell infiltration and redox reactions weren't highly differentiated between the two conditions. Nevertheless, it did find certain pathways that are relevant to NAFLD, such as extracellular structure organization (which helps maintain the complex network of proteins and carbohydrates that support cells in tissues and organs), pathways involved in the lumen (affecting the absorption and digestion of nutrients), the AGE-RAGE signaling pathway in diabetic complications, which could correspond to the insulin resistance in NAFLD patients. Further studies are warranted to elucidate the complex mechanisms underlying the involvement of these pathways in NAFLD.

# III. Discussion:

During the course of the research project, there were several issues or limitations that I had to deal with by adjusting methods and approaches. One issue is that the biological processess driving the disease phenotype vary with disease severity. NAFLD is an umbrella term, meaning it encapsulates a complex disease with many phenotypes. Although samples may have been histologically assessed to be in similar disease states, it is likely that the processes involved in each sample or individual vary. This lack of consistency between samples can also be attributed to the limited availability of tissue samples. Due to the lack of available time to process, I tried my best to choose only four replicate samples for each condition with similar attributes (women over the age of 60), however just basing these replicates on age and sex is not enough. Further information on weight, race and even diet could've helped make each of my replicates more similar and aid in the consistency between samples of the same condition. Also, the high levels of RNase in the liver could have affected the study as well. While this is difficult to control, it most likely has some effect on our samples and could have skewed our gene expression data. Finally, a limitation of the study is that gene expression levels alone may not predict translation into protein or the functionality of the proteins. Gene expression serves as a proxy for a wide range of biological processes and cellular functions, and should be used as a tool to provide insights into the underlying molecular mechanisms of a disease, it should not be taken directly as protein level expression.

# IV. Methods:

## A. Data Collection and Pre-processing

For this study, I decided to use samples from Hoang et al 2019. This data was generated by HemoShear Therapeutics and the RNA was extracted from liver biospy cells using a Qiagen RNease RNA isolation kit. This kit uses polyA-oligo-dT based purification of mRNA. cDNA libraries were prepared using the Illumina TruSeq Stranded mRNA Sample Preparation kit. This library prep is stranded, and the data is paired end. All raw data is available through the Gene Expression Omnibus, Accession Number GSE130970.

Samples were separated into groups by two factors, NAS score and fibrosis stage score. The NAFLD disease activity is captured by the NAFLD activity score (NAS), which is the sum of the histological severity scores for steatosis, lobular inflamation and hepatocellular ballooning. The fibrosis stage can be used as a prognosis for the severity of NAFLD and has been shown to predict mortality and time to development of severe liver disease (Taylor et al, 2020 and Angulo et al 2015). Both of these scores were based on histological assessments. In this study, I decided to use 8 patient samples, 4 samples representing each of the two groups: "LOW NAFLD" characterized by normal/low NAS score (NAS scores of 0 and 1 sample with 1) and early fibrosis stage (stage 0), and "HIGH NAFLD" characterized by high NAS score (NAS scores of 5 or 6) and late fibrosis stage (stage 3). The average age of patients where NAFLD high samples were taken was 68.25, while the average age of patients where NAFLD low samples were taken from is 61.25

I've supplied a NAFLD_Sample_Notes sheet, which gives the fibrosis stage and NAFLD scores for each patient's samples.
More detailed information on each sample can be found here: https://www.ncbi.nlm.nih.gov/Traces/study/?acc=PRJNA542148&o=acc_s%3Aa

### 1. Getting the FASTQ Files

I got a list of FASTQ files from the SRA Accession website and made the below csv, called sample_sras.csv.
```
SRR9036307_1,
SRR9036307_2,
SRR9036311_1,
SRR9036311_2,
SRR9036380_1,
SRR9036380_2,
SRR9036314_1,
SRR9036314_2,
SRR9036377_1,
SRR9036377_2,
SRR9036379_1,
SRR9036379_2,
SRR9036384_1,
SRR9036384_2,
SRR9036357_1,
SRR9036357_2,
```
Please keep in mind: For this and future scripts, I decided to removed the sbatch commands that dictate the number of nodes, tasks and memory used for processing.

The below bash script, called Download_fastqs.sh, takes the samples from the sample_sras.csv and downloads the necessary contents. This was the first executed command. 
```
# Define the path to the CSV file
csv_file="sample_sras.csv"

# Loop through each line in the CSV file
for line in $(cat "$csv_file"); do
    string="${line::-2}"
    trimmed="${line::-4}"
    #echo $string
    #echo $trimmed
  # Use wget to download the URL specified in the current line
  wget ftp://ftp.sra.ebi.ac.uk/vol1/fastq/SRR903/007/$trimmed/$string.fastq.gz

done

echo 'Finished'
```

### 2. Rename FastQs

Next, I wanted to rename the fastqs to allow for more proper identification. Therefore, I made a secondary csv file with the new names, called new_names.csv. Below are the contents.
```
HIGH_NAFLD1_1,
HIGH_NAFLD1_2,
HIGH_NAFLD2_1,
HIGH_NAFLD2_2,
HIGH_NAFLD3_1,
HIGH_NAFLD3_2,
HIGH_NAFLD4_1,
HIGH_NAFLD4_2,
LOW_NAFLD1_1,
LOW_NAFLD1_2,
LOW_NAFLD2_1,
LOW_NAFLD2_2,
LOW_NAFLD3_1,
LOW_NAFLD3_2,
LOW_NAFLD4_1,
LOW_NAFLD4_2,
```
Then, I decided to make a script in order to rename the old fastq files to the new names. This code was the second to be executed. This is called rename_fastq.sh:
```
# Define the path to the CSV file
csv_file="sample_sras.csv"
csv_new_name="new_names.csv"

line_count=$(wc -l < $csv_file)
name_count=$(wc -l < $csv_new_name)

# Loop through each line in the CSV file
if [[ "$line_count" == "$name_count" ]]; then
    for line_num in `seq 1 $line_count`;
    do
        old_name=$(awk -F ',' "NR==$line_num" $csv_file) #SRR9036357_2
        new_name=$(awk -F ',' "NR==$line_num" $csv_new_name)
        old_name_trim=${old_name%??}
        new_name_trim=${new_name%?}
        #echo $old_name_trim
        #echo $new_name_trim
        # Use mv to rename the fastqfiles to our sample names
        mv /home/nam4021/project/project_org/fastqfiles/$old_name_trim.fastq.gz /home/nam4021/project/project_org/fastqfiles/$new_name_trim.fastq.gz
        #echo old: /home/nam4021/project/project_org/fastqfiles/$old_name_trim.fastq.gz
        #echo new: /home/nam4021/project/project_org/fastqfiles/$new_name_trim.fastq.gz
        #mv /home/nam4021/project/project_org/fastqfiles/LOW_NAFLD4_2,.fastq.gz /home/nam4021/project/project_org/fastqfiles/LOW_NAFLD4_2.fastq.gz
    done
else
    echo "CSV of Fastq files and new names are not the same length"
fi

## ONE ISSUE IS THE LAST NEW FILE NAME HAS A COMMA AT THE END, NEED TO MANUALLY CHANGE
mv /home/nam4021/project/project_org/fastqfiles/LOW_NAFLD4_2,.fastq.gz /home/nam4021/project/project_org/fastqfiles/LOW_NAFLD4_2.fastq.gz

echo 'Finished'
```
Unfortunately, due to the format of the csv file, I had to rename the LOW_NAFLD4_2,.fastq.gz file in the last few lines as a correction. No other parameters, besides memory allocation, were necessary in the actual loop and function.

### 3. FastQC - Sequence Quality Control

I also made a different script called fastqc_NAFLD.sh. These I manually input for each file, however using a for loop could have been a more proper way to do so. Here, no further parameters were needed for fastqc besides the input file, the --extract since the fastq file is gzipped, and the out directory.
```
mamba activate angsd

fastqc /home/nam4021/project/project_org/fastqfiles/HIGH_NAFLD1_1.fastq.gz --extract --outdir /athena/angsd/scratch/nam4021/fastqc_NAFLD
fastqc /home/nam4021/project/project_org/fastqfiles/HIGH_NAFLD1_2.fastq.gz --extract --outdir /athena/angsd/scratch/nam4021/fastqc_NAFLD
fastqc /home/nam4021/project/project_org/fastqfiles/HIGH_NAFLD2_1.fastq.gz --extract --outdir /athena/angsd/scratch/nam4021/fastqc_NAFLD
fastqc /home/nam4021/project/project_org/fastqfiles/HIGH_NAFLD2_2.fastq.gz --extract --outdir /athena/angsd/scratch/nam4021/fastqc_NAFLD
fastqc /home/nam4021/project/project_org/fastqfiles/HIGH_NAFLD3_1.fastq.gz --extract --outdir /athena/angsd/scratch/nam4021/fastqc_NAFLD
fastqc /home/nam4021/project/project_org/fastqfiles/HIGH_NAFLD3_2.fastq.gz --extract --outdir /athena/angsd/scratch/nam4021/fastqc_NAFLD
fastqc /home/nam4021/project/project_org/fastqfiles/HIGH_NAFLD4_1.fastq.gz --extract --outdir /athena/angsd/scratch/nam4021/fastqc_NAFLD
fastqc /home/nam4021/project/project_org/fastqfiles/HIGH_NAFLD4_2.fastq.gz --extract --outdir /athena/angsd/scratch/nam4021/fastqc_NAFLD
fastqc /home/nam4021/project/project_org/fastqfiles/LOW_NAFLD1_1.fastq.gz --extract --outdir /athena/angsd/scratch/nam4021/fastqc_NAFLD
fastqc /home/nam4021/project/project_org/fastqfiles/LOW_NAFLD1_2.fastq.gz --extract --outdir /athena/angsd/scratch/nam4021/fastqc_NAFLD
fastqc /home/nam4021/project/project_org/fastqfiles/LOW_NAFLD2_1.fastq.gz --extract --outdir /athena/angsd/scratch/nam4021/fastqc_NAFLD
fastqc /home/nam4021/project/project_org/fastqfiles/LOW_NAFLD2_2.fastq.gz --extract --outdir /athena/angsd/scratch/nam4021/fastqc_NAFLD
fastqc /home/nam4021/project/project_org/fastqfiles/LOW_NAFLD3_1.fastq.gz --extract --outdir /athena/angsd/scratch/nam4021/fastqc_NAFLD
fastqc /home/nam4021/project/project_org/fastqfiles/LOW_NAFLD3_2.fastq.gz --extract --outdir /athena/angsd/scratch/nam4021/fastqc_NAFLD
fastqc /home/nam4021/project/project_org/fastqfiles/LOW_NAFLD4_1.fastq.gz --extract --outdir /athena/angsd/scratch/nam4021/fastqc_NAFLD
fastqc /home/nam4021/project/project_org/fastqfiles/LOW_NAFLD4_2.fastq.gz --extract --outdir /athena/angsd/scratch/nam4021/fastqc_NAFLD
```

### 4. STAR Indexing and Alignment

For this, I decided to build a new index for the GRCh38.p14 human genome. 

I found the necessary Genome sequence (FASTA) and annotation features (GFF) at the below websites:
https://www.ncbi.nlm.nih.gov/data-hub/genome/GCF_000001405.40/
https://ftp.ncbi.nlm.nih.gov/genomes/refseq/vertebrate_mammalian/Homo_sapiens/latest_assembly_versions/GCF_000001405.40_GRCh38.p14/. This gff file was recently updated in February 2022 and is version GRCh38.p14. It is also provided by the NCBI RefSeq. 

In the Hoang et al paper, GRCh37.75 from Ensembl was used, along with Salmon (run in a GC bias-aware mode), and using a TMM normalization method from edgeR. Finally, counts and normalized library sizes were used to transform gene-level counts into log2(CPM) values. My reference, alignment process and normalization methods were different, but I wanted to see if my results from these samples would match a similar paper on NAFLD patients. I also decided to use the genome assembly and annotations I chose due to the recent updates and the high amount of annotation, which later I realized isn't always the best way to annotate data.

I chose the following parameters based on --runThreadN 6 and --sjdbOverhang 99. This is so it will run in 6 different threads in parallel, and I've used the 99 overhang because it is the default value. The individual reads are 51 bp, therefore 99 overhand is fine, even though the database will be a bit larger than necessary. I've kept the number of nodes and tasks as the default (=1). Our gff file is still compatible with the --sjdbGTFfile command. This script is named Create_hg38_index.sh.
```
mamba activate angsd

echo 'Starting STAR indexing now'

STAR --runThreadN 6 --runMode genomeGenerate --genomeDir /athena/angsd/scratch/nam4021/hg38_Index --genomeFastaFiles /home/nam4021/project/ncbi_dataset/data/GCF_000001405.40/GCF_000001405.40_GRCh38.p14_genomic.fna --sjdbGTFfile /home/nam4021/project/ncbi_dataset/data/GCF_000001405.40/genomic.gff --sjdbOverhang 99

echo 'Finished'
```

Next, I decided to align these using the align_all_paired.sh file. As described in the script below and due to the formatting of the csv's (as mentioned in the above re-name script), LOW_NAFLD4 had different parsing than the others from the new_names.csv. The runthread is set to 8, so it will run in parallel different threads. I've also used the gunzip readFilesCommand in order to use the fastq.gz files.

I realized after running this alignment, I could've used the genome.ucsc website (https://genome.ucsc.edu/cgi-bin/hgTables) in order to assess the Intron Minimum and input this factor. After selecting the proper genome assembly, .bed output file and selecting to create one BED record per Introns plus 0 bases at each end, I've supplied the introns.bed file included in my github datasets (zipped to maximize the storage efficiency). You can run the below commands to extract the smallest and largest intron values.

Below gives us the smallest intron values: The results are- 1, 2, 10.
```
awk '{print $3 - $2} ' introns.bed | sort -n | uniq | head -n 3
```
Below gives us the largest intron values: The results are- 1160411, 1097903, 1068357
```
awk '{print $3 - $2} ' introns.bed | sort -rn | uniq | head -n 3
```
Therefore, in the future '#--alignIntronMin 10  --alignIntronMax 1200000' should be used, as mentioned in the script. 

I also could've changed the outTmpDir, to use the scratch folder as the temporary directory that STAR uses to sort. If I re-run the samples, I'll be sure to include these parameters. This is also mentioned in the script.

Other parameters include the need to specify STAR to --runMode alignReads, since we are using the alignment function, and specifying that our output should be BAM and Sorted by Coordinate.

```
echo 'Starting STAR alignment now'

# Define the path to the CSV file
csv_file="sample_sras.csv"
csv_new_name="new_names.csv"
### --readFilesIn LOW_NAFLD3_1.fastq.gz LOW_NAFLD3_2.fastq.gz OTHERS LOOK FINE
## --readFilesIn LOW_NAFLD4__1.fastq.gz LOW_NAFLD4__2.fastq.gz SOMEHOW NAFLD4 is doing this

# Loop through each line in the CSV file
#for line in $(cat "$csv_file"); do

for 
awk 'NR % 2 == 0' "$csv_new_name" | while read line
do
    string="${line::-2}"
    trimmed="${line::-3}"
    forfour="${line::-4}"
    forfour1="${forfour}_1"
    forfour2="${forfour}_2"
    lastdig="${trimmed:${#trimmed}-1}"
    trimmed_1="${trimmed}_1"
    trimmed_2="${trimmed}_2"
    echo $string
    echo $trimmed
    echo $trimmed_1
    echo $trimmed_2

    #/home/nam4021/project/project_org/fastqfiles/$new_name_trim.fastq.gz
    if [ $string =  'LOW_NAFLD4_2' ]; then
    echo "Check for Low 4"
    #echo "$forfor"
    #echo "--readFilesIn $forfour1.fastq.gz $forfour2.fastq.gz"
    #echo "--outFileNamePrefix /home/nam4021/project/project_org/star_NAFLD/$trimmed " \ 

      # Use wget to download the URL specified in the current line
    STAR --runMode alignReads \
     --runThreadN 8 \
     --genomeDir /athena/angsd/scratch/nam4021/hg38_Index  \
     --readFilesCommand gunzip -c \
     --readFilesIn /home/nam4021/project/project_org/fastqfiles/$forfour1.fastq.gz /home/nam4021/project/project_org/fastqfiles/$forfour2.fastq.gz \
     --outFileNamePrefix /athena/angsd/scratch/nam4021/star_NAFLD/$forfour \
     --outSAMtype BAM SortedByCoordinate
    
else
    #echo  "--readFilesIn $trimmed_1.fastq.gz $trimmed_2.fastq.gz"
    #echo  " --outFileNamePrefix /home/nam4021/project/project_org/star_NAFLD/$string " \
      # Use wget to download the URL specified in the current line
    STAR --runMode alignReads \
     --runThreadN 8 \
     --genomeDir /athena/angsd/scratch/nam4021/hg38_Index  \
     --readFilesCommand gunzip -c \
     --readFilesIn /home/nam4021/project/project_org/fastqfiles/$trimmed_1.fastq.gz /home/nam4021/project/project_org/fastqfiles/$trimmed_2.fastq.gz \
     --outFileNamePrefix /athena/angsd/scratch/nam4021/star_NAFLD/$trimmed \
     --outSAMtype BAM SortedByCoordinate
     #--alignIntronMin 10  --alignIntronMax 1200000 https://genome.ucsc.edu/cgi-bin/hgTables to an external site.
     # -- outTmpDir /localScratch
fi

done


echo 'Finished'
```

### 5. Samtools BAM File Indexing 

After this, I used the sam_index.sh script in order to index all the bam files. There really isn't any customization/parameters needed to be changed here. It's important to make sure the bam.bai files and bam files are within the same folder once indexed.
```
mamba activate angsd

# Define the directory containing the BAM files
bam_dir="/athena/angsd/scratch/nam4021/star_NAFLD"

# Loop through each BAM file in the directory and index it
for bam_file in "${bam_dir}"/*.bam
do
  samtools index "${bam_file}"
done


# In order words, accomplishes this
#samtools index HIGH_NAFLD1Aligned.sortedByCoord.out.bam
#samtools index HIGH_NAFLD2Aligned.sortedByCoord.out.bam
#samtools index HIGH_NAFLD3Aligned.sortedByCoord.out.bam
#samtools index HIGH_NAFLD4Aligned.sortedByCoord.out.bam
#samtools index LOW_NAFLD1Aligned.sortedByCoord.out.bam
#samtools index LOW_NAFLD2Aligned.sortedByCoord.out.bam
#samtools index LOW_NAFLD3Aligned.sortedByCoord.out.bam
#samtools index LOW_NAFLD4Aligned.sortedByCoord.out.bam
```

### 6. Alignment QC - BamQC, RSeQC 

Next, I decided to run BamQC and RSeQC. Qorts continued to provide an error due to the annotation file format (GFF3), and I wasn't able to find a conversion that was compatible. Therefore, I decided to run BamQC and RSeQC.

First, it was necessary to convert the gff file to a bed file for RSeQC compatability. In order to run RSEQC, I took my original gff file, and converted it to a gene pred file using bedops package in a mamba environment called gff3tobed.
```
mamba activate gff3tobed
gff2bed < /home/nam4021/project/ncbi_dataset/data/GCF_000001405.40/genomic.gff > /home/nam4021/project/genomic.bed
```

The below script is called QC_and_reads2.sh. For the BamQC, and RSeQC - read distribution and geneBody_coverage functions, few inputs were necessary. Including the BAM file, output directory or file name, and the annotation folder.

```
mamba activate rseqc

csv_new_name="new_names.csv"

echo "Starting QC and Reads"

awk 'NR % 2 == 0' "$csv_new_name" | while read line
do
    string="${line::-2}"
    trimmed="${line::-3}"
    forfour="${line::-4}"
    forfour1="${forfour}_1"
    forfour2="${forfour}_2"
    lastdig="${trimmed:${#trimmed}-1}"
    trimmed_1="${trimmed}_1"
    trimmed_2="${trimmed}_2"

    #/home/nam4021/project/project_org/fastqfiles/$new_name_trim.fastq.gz
    if [ $string =  'LOW_NAFLD4_2' ]; then
    echo "Check for Low 4"
    echo "$forfour"

        if [ -e "/athena/angsd/scratch/nam4021/reads/LOW_NAFLD4_body_coverage.out" ]; then
            echo "$forfour exists"

        else
            echo "$forfour does not exist"

            # Issue - not sure why my BAMQC outputs to the /athena/angsd/scratch/nam4021/star_NAFLD/ directory and not the specified QCout
            /softlib/apps/EL7/BamQC/bin/bamqc [-o /athena/angsd/scratch/nam4021/QCout] [-g /home/nam4021/project/ncbi_dataset/data/GCF_000001405.40] /athena/angsd/scratch/nam4021/star_NAFLD/LOW_NAFLD4Aligned.sortedByCoord.out.bam
        
            read_distribution.py -i /athena/angsd/scratch/nam4021/star_NAFLD/LOW_NAFLD4Aligned.sortedByCoord.out.bam -r /home/nam4021/project/genomic2.bed > /athena/angsd/scratch/nam4021/reads/LOW_NAFLD4_read_distribution.out

            geneBody_coverage.py -r /home/nam4021/project/genomic2.bed -i /athena/angsd/scratch/nam4021/star_NAFLD/LOW_NAFLD4Aligned.sortedByCoord.out.bam -o /athena/angsd/scratch/nam4021/reads/LOW_NAFLD4_body_coverage.out
        fi
else
    echo "$trimmed"

    if [ -e "/athena/angsd/scratch/nam4021/reads/"$trimmed"_read_distribution.out" ]; then
        echo "$trimmed exists"

    else
        echo "$trimmed does not exist"


        /softlib/apps/EL7/BamQC/bin/bamqc [-o /athena/angsd/scratch/nam4021/QCout] [-g /home/nam4021/project/ncbi_dataset/data/GCF_000001405.40] /athena/angsd/scratch/nam4021/star_NAFLD/"$trimmed"Aligned.sortedByCoord.out.bam

        read_distribution.py -i /athena/angsd/scratch/nam4021/star_NAFLD/"$trimmed"Aligned.sortedByCoord.out.bam -r /home/nam4021/project/genomic2.bed > /athena/angsd/scratch/nam4021/reads/"$trimmed"_read_distribution.out

        geneBody_coverage.py -r /home/nam4021/project/genomic2.bed -i /athena/angsd/scratch/nam4021/star_NAFLD/"$trimmed"Aligned.sortedByCoord.out.bam -o /athena/angsd/scratch/nam4021/reads/"$trimmed"_body_coverage.out
    fi
fi

done


echo 'Finished'
```

### 7. MultiQC

Using the below command, I brought together all the QC results together into multiqc_report_04_03_2023.html. 
```
mamba activate multiqc
multiqc /athena/angsd/scratch/nam4021/fastqc_NAFLD /athena/angsd/scratch/nam4021/star_NAFLD /athena/angsd/scratch/nam4021/reads -o /athena/angsd/scratch/nam4021/QCout 
```

The FASTQC looks pretty good! The per base sequence content failed due to the first 11-15 bases for each file, which is common for RNA-seq data. 

Overall, the 1st replicated (Sequence duplication failed as well, but even after de-duplication there were many different sequences found to be duplicated. However, other quality measures showed good quality. Adapter content was very low in the untrimmed fastq file and nothing changed with the trimmed fastqc except for the sequence length distribution changing slightly in my previous analysis. Therefore, I didn't find the need to use the trimmed.

I don't see evidence to support adapter/primer or any other contamination. There is significantly higher overrepresented sequences in the _1 stranded fastq files, compared to the _2 for each sample, however it is not concerningly high. GC distribution looks good. 

The quality looks good for genome coverage, chromosome read density and other statistics, but the Mapping Quality histogram shows only around 55-60% of reads in the 248+ quality reads.

The RSeQC shows that most of the captured RNAs are exonic and there is not a pronounced 3'/5' bias (no prominent RNA degradation). 

### 8. Basic Alignment QC
For the basic alignment QC, I ran the below commands.
```
(angsd) [nam4021@buddy star_NAFLD]$ samtools flagstat HIGH_NAFLD1Aligned.sortedByCoord.out.bam 
164314386 + 0 in total (QC-passed reads + QC-failed reads)
131535322 + 0 primary
32779064 + 0 secondary
0 + 0 supplementary
0 + 0 duplicates
0 + 0 primary duplicates
164314386 + 0 mapped (100.00% : N/A)
131535322 + 0 primary mapped (100.00% : N/A)
131535322 + 0 paired in sequencing
65767661 + 0 read1
65767661 + 0 read2
131535322 + 0 properly paired (100.00% : N/A)
131535322 + 0 with itself and mate mapped
0 + 0 singletons (0.00% : N/A)
0 + 0 with mate mapped to a different chr
0 + 0 with mate mapped to a different chr (mapQ>=5)

(angsd) [nam4021@buddy star_NAFLD]$ samtools flagstat HIGH_NAFLD2Aligned.sortedByCoord.out.bam 
123334824 + 0 in total (QC-passed reads + QC-failed reads)
101016752 + 0 primary
22318072 + 0 secondary
0 + 0 supplementary
0 + 0 duplicates
0 + 0 primary duplicates
123334824 + 0 mapped (100.00% : N/A)
101016752 + 0 primary mapped (100.00% : N/A)
101016752 + 0 paired in sequencing
50508376 + 0 read1
50508376 + 0 read2
101016752 + 0 properly paired (100.00% : N/A)
101016752 + 0 with itself and mate mapped
0 + 0 singletons (0.00% : N/A)
0 + 0 with mate mapped to a different chr
0 + 0 with mate mapped to a different chr (mapQ>=5)

(angsd) [nam4021@buddy star_NAFLD]$ samtools flagstat HIGH_NAFLD3Aligned.sortedByCoord.out.bam 
125216540 + 0 in total (QC-passed reads + QC-failed reads)
104052616 + 0 primary
21163924 + 0 secondary
0 + 0 supplementary
0 + 0 duplicates
0 + 0 primary duplicates
125216540 + 0 mapped (100.00% : N/A)
104052616 + 0 primary mapped (100.00% : N/A)
104052616 + 0 paired in sequencing
52026308 + 0 read1
52026308 + 0 read2
104052616 + 0 properly paired (100.00% : N/A)
104052616 + 0 with itself and mate mapped
0 + 0 singletons (0.00% : N/A)
0 + 0 with mate mapped to a different chr
0 + 0 with mate mapped to a different chr (mapQ>=5)

(angsd) [nam4021@buddy star_NAFLD]$ samtools flagstat HIGH_NAFLD4Aligned.sortedByCoord.out.bam 
139899310 + 0 in total (QC-passed reads + QC-failed reads)
105565702 + 0 primary
34333608 + 0 secondary
0 + 0 supplementary
0 + 0 duplicates
0 + 0 primary duplicates
139899310 + 0 mapped (100.00% : N/A)
105565702 + 0 primary mapped (100.00% : N/A)
105565702 + 0 paired in sequencing
52782851 + 0 read1
52782851 + 0 read2
105565702 + 0 properly paired (100.00% : N/A)
105565702 + 0 with itself and mate mapped
0 + 0 singletons (0.00% : N/A)
0 + 0 with mate mapped to a different chr
0 + 0 with mate mapped to a different chr (mapQ>=5)

(angsd) [nam4021@buddy star_NAFLD]$ samtools flagstat LOW_NAFLD1Aligned.sortedByCoord.out.bam 
118733936 + 0 in total (QC-passed reads + QC-failed reads)
97770092 + 0 primary
20963844 + 0 secondary
0 + 0 supplementary
0 + 0 duplicates
0 + 0 primary duplicates
118733936 + 0 mapped (100.00% : N/A)
97770092 + 0 primary mapped (100.00% : N/A)
97770092 + 0 paired in sequencing
48885046 + 0 read1
48885046 + 0 read2
97770092 + 0 properly paired (100.00% : N/A)
97770092 + 0 with itself and mate mapped
0 + 0 singletons (0.00% : N/A)
0 + 0 with mate mapped to a different chr
0 + 0 with mate mapped to a different chr (mapQ>=5)

(angsd) [nam4021@buddy star_NAFLD]$ samtools flagstat LOW_NAFLD2Aligned.sortedByCoord.out.bam 
134677736 + 0 in total (QC-passed reads + QC-failed reads)
110673362 + 0 primary
24004374 + 0 secondary
0 + 0 supplementary
0 + 0 duplicates
0 + 0 primary duplicates
134677736 + 0 mapped (100.00% : N/A)
110673362 + 0 primary mapped (100.00% : N/A)
110673362 + 0 paired in sequencing
55336681 + 0 read1
55336681 + 0 read2
110673362 + 0 properly paired (100.00% : N/A)
110673362 + 0 with itself and mate mapped
0 + 0 singletons (0.00% : N/A)
0 + 0 with mate mapped to a different chr
0 + 0 with mate mapped to a different chr (mapQ>=5)

(angsd) [nam4021@buddy star_NAFLD]$ samtools flagstat LOW_NAFLD3Aligned.sortedByCoord.out.bam 
121912290 + 0 in total (QC-passed reads + QC-failed reads)
101095978 + 0 primary
20816312 + 0 secondary
0 + 0 supplementary
0 + 0 duplicates
0 + 0 primary duplicates
121912290 + 0 mapped (100.00% : N/A)
101095978 + 0 primary mapped (100.00% : N/A)
101095978 + 0 paired in sequencing
50547989 + 0 read1
50547989 + 0 read2
101095978 + 0 properly paired (100.00% : N/A)
101095978 + 0 with itself and mate mapped
0 + 0 singletons (0.00% : N/A)
0 + 0 with mate mapped to a different chr
0 + 0 with mate mapped to a different chr (mapQ>=5)

(angsd) [nam4021@buddy star_NAFLD]$ samtools flagstat LOW_NAFLD4Aligned.sortedByCoord.out.bam 
131560010 + 0 in total (QC-passed reads + QC-failed reads)
109421558 + 0 primary
22138452 + 0 secondary
0 + 0 supplementary
0 + 0 duplicates
0 + 0 primary duplicates
131560010 + 0 mapped (100.00% : N/A)
109421558 + 0 primary mapped (100.00% : N/A)
109421558 + 0 paired in sequencing
54710779 + 0 read1
54710779 + 0 read2
109421558 + 0 properly paired (100.00% : N/A)
109421558 + 0 with itself and mate mapped
0 + 0 singletons (0.00% : N/A)
0 + 0 with mate mapped to a different chr
0 + 0 with mate mapped to a different chr (mapQ>=5)
```
The alignment looks like it worked well! All of the reads passed the QC test for the total number of reads, the number of mapped reads and the mapping rate. There were no reads mapped as singletons, mapped to different chromosomes or mapped to the same chromosome but on different strands.

### 9. Read Counts

Finally, I ran the below script, called feature_counts.sh, in order to get the feature counts from all of the corresponding bam files.

For this, there were multiple necessary input parameters to successfully count the features. -s 2 was necessary since the fasta/bam files were reverse stranded. -g gene was necessary to specify the feature (gene for gff3 files). -p --countReadPairs tells the program that it is paired end data. -a specifies the annotation file. -F is default set as GTF, which is compatible with gff for featureCounts and -t exon is also the default value. I decided to not include -O for overlaps or anything for multimapping. -f isn't necessary either.
```
mamba activate angsd

featureCounts -p --countReadPairs -s 2 \
                -g gene -a /home/nam4021/project/ncbi_dataset/data/GCF_000001405.40/genomic.gff \
                -o /athena/angsd/scratch/nam4021/gene_counts_NAFLD_gene \
              /athena/angsd/scratch/nam4021/star_NAFLD/HIGH_NAFLD1Aligned.sortedByCoord.out.bam \
              /athena/angsd/scratch/nam4021/star_NAFLD/HIGH_NAFLD2Aligned.sortedByCoord.out.bam \
              /athena/angsd/scratch/nam4021/star_NAFLD/HIGH_NAFLD3Aligned.sortedByCoord.out.bam \
              /athena/angsd/scratch/nam4021/star_NAFLD/HIGH_NAFLD4Aligned.sortedByCoord.out.bam \
              /athena/angsd/scratch/nam4021/star_NAFLD/LOW_NAFLD1Aligned.sortedByCoord.out.bam \
              /athena/angsd/scratch/nam4021/star_NAFLD/LOW_NAFLD2Aligned.sortedByCoord.out.bam \                /athena/angsd/scratch/nam4021/star_NAFLD/LOW_NAFLD3Aligned.sortedByCoord.out.bam \
              /athena/angsd/scratch/nam4021/star_NAFLD/LOW_NAFLD4Aligned.sortedByCoord.out.bam
```

Then I used scp to transfer the output from on the scratch directory to my local computer.

In the next Rmd and html files, called Read_counts_NAFLD.rmd and .html, I proceed to take this output and input it into R!

### 10. Mamba environments

All the mamba environments used for this analysis are available in the Mamba environments folder.
From: mamba env list:
```
# conda environments:
#
angsd                    /athena/angsd/scratch/mef3005/share/envs/angsd
multiqc                  /athena/angsd/scratch/mef3005/share/envs/multiqc
qorts                    /athena/angsd/scratch/mef3005/share/envs/qorts
r42-deseq                /athena/angsd/scratch/mef3005/share/envs/r42-deseq
rseqc                    /athena/angsd/scratch/mef3005/share/envs/rseqc
trim-galore              /athena/angsd/scratch/mef3005/share/envs/trim-galore
base                     /pbtech_mounts/homes064/nam4021/mambaforge
gff3tobed             *  /pbtech_mounts/homes064/nam4021/mambaforge/envs/gff3tobed
```
I created the yml min and full lists using the below commands. Replacing venv with each of the conda environments above.
```
mamba env export -n venv --from-history > /home/nam4021/project/project_org/mamba_env/venv.min.yaml
mamba env export -n venv > /home/nam4021/project/project_org/mamba_env/venv.full.yaml

scp -r nam4021@aphrodite.med.cornell.edu://home/nam4021/project/project_org/mamba_env /Users/johnmorris/Desktop/Comp_Bio_MS_Weill_Cornell/Spring_2023/ANGSD/Project_Download/ANGSD_NAFLD_Project_2023/Mamba\ Environments
```

## B. Data Analysis and Downstream Processing

### 1. Read in the featureCounts summary and graph

```{r,warning=FALSE,message=FALSE}
## For Feature Counts Summary Graph
library(dplyr)
library(data.table)
library(ggplot2)
```

```{r}
nafld_fc <- read.table("/Users/johnmorris/Desktop/Comp_Bio_MS_Weill_Cornell/Spring_2023/ANGSD/Project_Download/final_project_scripts/gene_counts_NAFLD_gene_reverse_stranded.summary")
row.names(nafld_fc) <- nafld_fc[,1]
nafld_fc<- nafld_fc[,-1]
nafld_fc[1,] <- c(paste("HIGH", c(1:4), sep = "_"), paste("LOW", c(1:4), sep = "_"))

transposed_second <- data.frame(t(nafld_fc))
transposed_second_new <- transposed_second[, c(1,2,10,13,15)]

long_new <- melt(setDT(transposed_second_new), id.vars = c("Status"))

long_new$value <- as.numeric(long_new$value)
ggplot(data = long_new, aes(x=Status, y = value, fill = variable) ) + geom_bar(stat="identity", position='dodge') + ylab("# reads") + xlab("samples") + coord_flip()
```

As you can see, the feature/read count distribution shows many samples assigned to no features and to multimapping. This is due to the fact that I decided to not assign multi-mapped features (reads that are multiple places on the genome), and our GFF file contains many features. I initially thought was the more features would lead to more assigned features, however this isn't always the case.

### 2. Reading in featureCounts results

```{r}
# Read in the data
folder <- "/Users/johnmorris/Desktop/Comp_Bio_MS_Weill_Cornell/Spring_2023/ANGSD/Project_Download/final_project_scripts/gene_counts_NAFLD_gene_reverse_stranded" # download count table! ## reading in featureCounts output
readcounts <- read.table(t(folder), header = TRUE)
length(rownames(readcounts)) # Here you can see that we have a total of 49306 genes
```

#### Create Read Counts Table
```{r}
#write.table(readcounts, file = "readcounts.txt", sep = "\t", row.names = TRUE, col.names = TRUE)
```

### 3. Changing the rownames to represent the conditions and replicate names

```{r}
original_names <- names(readcounts)
names(readcounts) <- c(names(readcounts)[1:6],
  "HIGH_1", "HIGH_2", "HIGH_3", "HIGH_4", "LOW_1",
  "LOW_2", "LOW_3", "LOW_4")
#str(readcounts)
```

### 4. DESeq2 object set up and readcounts assay organization

```{r,warning=FALSE,message=FALSE}
#BiocManager::install("DESeq2")
library(DESeq2)
```

```{r}
row.names(readcounts) <- make.names(readcounts$Geneid)

# Eliminate unnecessary rows
readcounts <- readcounts[ , -c(1:6)]
head(readcounts)

## Create sample_info
sample_info <- data.frame(condition = gsub("[0-9]+", "", names(readcounts)),
                         row.names = names(readcounts) )

# Create the DESeq object
DESeq.ds <- DESeqDataSetFromMatrix(countData = as.matrix(readcounts),
                                   colData = sample_info,
                                   design = ~ condition)
DESeq.ds
head(counts(DESeq.ds))

# Check the sums of the reads for each condition
colSums(counts(DESeq.ds))
barplot(colSums(counts(DESeq.ds)), main = "Total Counts", ylab = "Counts #", xlab = "Condition", las = 2)
```
The sum of each replicate and condition matches the total counts we see from the summary featureCounts table, as well as in the QC.


```{r}
# Original dimensions with empty genes
paste0("The original dimensions of the object including empty genes is: ")
dim(DESeq.ds)
```

```{r,warning=FALSE,message=FALSE}
# Pre-filtering low count genes before running DESeq2 functions
library(magrittr)
```

```{r}
keep_genes <- rowSums(counts(DESeq.ds)) > 0
DESeq.ds <- DESeq.ds[ keep_genes, ]
paste0("The original dimensions of the object excluding empty genes is: ")
dim(DESeq.ds)
#counts(DESeq.ds) %>% str
#assay(DESeq.ds) %>% str
```

### 5. Normalizing for sequence depth and RNA composition differences

Raw read counts are strongly influenced by the actual expression level, but they are also impacted by the gene length, transcript sequence (%GC), sequence depth, the expression of all the other genes in the same sample and which method we chose to deal with multimapped reads. Here, we can normalize the samples to minimize the impact of these effects.

```{r}
# Calculate the size factors and add them to the object
DESeq.ds <- estimateSizeFactors(DESeq.ds)
# Assess the size factors
plot(sizeFactors(DESeq.ds), colSums(counts(DESeq.ds)),
      ylab = "library sizes", xlab = "size factors", cex = .6 )
```

```{r}
# Extracting normalized counts
counts.sf_normalized <- counts(DESeq.ds, normalized=TRUE)
# Creating the boxplots to compare normalized vs non-normalized reads
par(mfrow=c(1,2))
boxplot(counts(DESeq.ds), main = "read counts only", cex = .6)
boxplot(counts.sf_normalized, main = "SF normalized", cex = .6)
```

In the above, we can check whether the normalization helped adjust global differences between samples. However, due to the different scales, it is hard to compare. Below, we can see them with similar scales by log2 transforming the counts.

```{r}
# Transform the normalized read counts to bring them onto similar scales

# Boxplot of non-normalized
par(mfrow=c(1,2))
boxplot(log2(counts(DESeq.ds) +1), notch=TRUE,
        main = "Non-normalized read counts",
        ylab ="log2(read counts)", cex = .6, las = 2)
# Boxplot of size-factor normalized values
boxplot(log2(counts(DESeq.ds, normalized=TRUE) +1), notch=TRUE,
        main = "Size-factor-normalized read counts",
        ylab ="log2(read counts)", cex = .6, las = 2)
```

As you can see, across the replicates, the size factor normalization of the read counts worked well.

#### a. Understanding more properties of read count data

```{r}
## Make a scatterplot of log normalized counts against each other to see how well the values correlate within a condition per sample and gene. Here we focus on two samples.

## non-normalized read counts plus pseudocount
log.counts <- log2(counts(DESeq.ds, normalized = FALSE) + 1)
## instead of creating a new object, we could assign the values to a distinct matrix ## within the DESeq.ds object
assay(DESeq.ds, "log.counts") <- log2(counts(DESeq.ds, normalized = FALSE) + 1)
## normalized read counts
assay(DESeq.ds, "log.norm.counts") <- log2(counts(DESeq.ds, normalized=TRUE) + 1)
par(mfrow=c(1,2))
DESeq.ds[, c("HIGH_1","HIGH_2")] %>%
  assay(.,  "log.norm.counts") %>%
  plot(., cex=.1, main = "HIGH_1 vs. HIGH_2")
DESeq.ds[, c("LOW_1","LOW_2")] %>%
  assay(.,  "log.norm.counts") %>%
  plot(., cex=.1, main = "LOW_1 vs LOW_2")
```

These plots comparing the log normalized counts for each gene between each sample and replicate should primarily only fan out at the lower levels, since they should correlate less well at lower expression, and come together at higher levels, since they should correlate more when the values increase. This indicates that the standard deviation of expression levels depends on the mean. However, for the HIGH condition, they don't correlate very well when they are high. For the LOW condition, they seem to correlate better.

```{r, }
#BiocManager::install("vsn")
library(vsn)
library(ggplot2)
```

```{r}
# Generate the base meanSdPlot using sequencing depth normalized log2(read counts)
par(mfrow=c(1,1)) # Setting up the plotting frame
# Generate the plot
msd_plot <- vsn::meanSdPlot(assay(DESeq.ds, "log.norm.counts"), ranks=FALSE, # show the data on the original scale
plot = FALSE)
msd_plot$gg +
  ggtitle("Sequencing depth normalized log2(read counts)") +
  ylab("standard deviation")
```

This depicts that there is a variance-mean dependence with low read counts, or else the red line would be horizontal. The data shows signs of heteroskedasticity (or a non-normal distribution of variances)!

#### b. Reducing the dependence of the variance on the mean

Rlog is the regularized log function. This shrinks the count data to a log2 scale, which minimizes the differences between samples for rows with small counts, and normalizes with respect to library size. Therefore, this allows us to base the variability of the genes on the overall average expression between all genes since it assumes that all genes that share similar average expression values should also display similar noise levels. This is the optimized method for RNA-seq. 

```{r}
DESeq.rlog <- rlog(DESeq.ds, blind = TRUE)
# Blind is set to TRUE because we want our results to be blind to the experimental design. This is because our null hypothesis is expecting there to not be any difference in the genes between the two conditions
par(mfrow=c(1,2))
plot(assay(DESeq.ds, "log.norm.counts")[,1:2], cex=.1,
     main = "size factor and log2-transformed")

## the rlog-transformed counts are stored in the "assay" accessor
plot(assay(DESeq.rlog)[,1:2],
     cex=.1, main = "rlog transformed",
     xlab = colnames(assay(DESeq.rlog[,1])),
     ylab = colnames(assay(DESeq.rlog[,2])) )
```

The rlog transformed plot seems to show lesser variance across all of the read counts.

We can set our rlog, normalized counts as the DESeq rlog assay.
```{r}
rlog.norm.counts <- assay(DESeq.rlog)
```

Now, we have expression values that have been adjusted for:
• differences in sequencing depth; 
• differences in RNA composition; 
• heteroskedasticity;
• large dynamic range.

```{r}
## rlog-transformed read counts
msd_plot <- vsn::meanSdPlot(assay(DESeq.rlog), ranks=FALSE, plot = FALSE)
msd_plot$gg + ggtitle("Following rlog transformation") +
  coord_cartesian(ylim = c(0,3))
```

Looks a lot better!

Save for future uses:

```{r}
#save.image(file = "/Users/johnmorris/Desktop/Comp_Bio_MS_Weill_Cornell/Spring_2023/ANGSD/Project_Download/ANGSD_NAFLD_Project_2023/Datasets/NAFLD_BulkRNA.RData")
```

### 4. Running the Differential Gene Expression Analysis

```{r}
library(magrittr)
library(DESeq2)

#FILE_DSD="/Users/johnmorris/Desktop/Comp_Bio_MS_Weill_Cornell/Spring_2023/ANGSD/Project_Download/ANGSD_NAFLD_Project_2023/Datasets/NAFLD_BulkRNA.RData"
#load(FILE_DSD)
#DESeq.ds
#DESeq.ds$condition
DESeq.ds$condition <- relevel(DESeq.ds$condition, ref = "LOW_") #Relevel to set the reference level to low
design(DESeq.ds)
# We also have DESeq.rlog

```

```{r}
DESeq.ds %<>% DESeq()

# The above line is equivalent to:
# normalize for diffs in sequencing depth and abundance per sample
# DESeq.ds %<>% estimateSizeFactors()
# gene-wise dispersion estimates across all samples
# DESeq.ds %<>% estimateDispersions()
# fit a neg. binomial GLM and compute Wald stat for each gene 
# DESeq.ds %<>% nbinomWaldTest()

# Now the DESeq object has additional entries in the rowdata column
DESeq.ds
rowData(DESeq.ds) %>% colnames
```

### 5. Adjusting for multiple hypothesis testing with independent filtering

When performing a large number of tests, p-values have a higher probability of representing a false positive outcome rather than a true positive outcome. For this reason, it is important to adjust the p-values, called multiple testing correction.

Before multiple testing correction, it is important to ignore genes with low read counts as we can't make assessments on their gene expression because the counts can be too unreliable and variable. The results() function of DESeq2 will try to find the optimal expression cut-off to maximize the number of genes that pass the adjusted p-value threshold. For genes with low reads, p-adj will be filled with NA.

```{r}
 rowData(DESeq.ds)$WaldPvalue_condition_HIGH__vs_LOW_ %>%
    hist(breaks=19, main="Raw p-values for LOW vs HIGH")
```

```{r}
DGE.results <- results(DESeq.ds, independentFiltering = TRUE, alpha = 0.05)
# Set independent filtering as true to apply the results function and ignore genes with low expression levels (NA p-adj value)
head(DGE.results)
summary(DGE.results)
table(DGE.results$padj < 0.05)
```

### 6. Shrinking logFC values

```{r}
#BiocManager::install("apeglm")
DGE.results <- lfcShrink(DESeq.ds, coef=2, type="apeglm")
# Use coefficient 2 because by checking resultsNames(DESeq.ds), we can see the second coefficient (condition_HIGH__vs_LOW_) tells us that the expression of the genes will be based on the conditions present here.
```

Shrinkage is necessary to shrink the lowly and noisily expressed genes towards zero. This makes these genes that are possibly skewed less important in our downstream analysis.

### 7. Assessing the DE results

```{r}
DGE.results$padj %>%
    hist(breaks=19, main="Adjusted p-values for HIGH vs LOW")
```

The results from the adjust p-values to indicate that there are 1897 genes that have values less than 0.05, as shown in the table previously. However, as you can see, there is also a high frequency of genes at other p-adj values. 

```{r}
DGE.results.sorted <- DGE.results %>% `[`(order(.$padj),)
head(DGE.results.sorted)
```
By looking at the first 6 genes that have the lowest p-adj values, we can see what these genes correlate to and if the analysis makes sense.

GPX2 encodes for a protein in the glutathione peroxidase family. It helps catalyze the reduction of organic hydroperoxides and hydrogen peroxide. It is present in the gastrointestinal tract and liver in humans. Overexpression of this gene is associated with increased differentiation and proliferation in gastrointestinal cancer (https://www.genecards.org/cgi-bin/carddisp.pl?gene=GPX2). It is related to the fatty acid metabolism and glutathione conjugation pathways.

AKR1B10 is a member of the aldo-keto reductase family and encodes for a protein that catalyzes the NADPH-dependent reduction of a wide variety of carbonyl-containing compounds. It is involved in the cyclophosphamide pathway/pharmacodynamics (https://www.genecards.org/cgi-bin/carddisp.pl?gene=AKR1B10) and may play an important role in liver carcinogenesis.

LOC124909347 and LINC01322 are associated with the non-coding RNA class. As you can see, the baseMean or expression value is considerably lower than the first two genes (https://www.genecards.org/cgi-bin/carddisp.pl?gene=LOC124909347, https://www.genecards.org/cgi-bin/carddisp.pl?gene=LINC01322).

PROZ encodes for a liver vitamin K-dependent glycoprotein that plays a role in regulating blood coagulation (https://www.genecards.org/cgi-bin/carddisp.pl?gene=PROZ).

LDL encodes for lipoprotein lipase, a key enzyme in triglyceride metabolism. Mutations are linked to many disorders of lipoprotein metabolism (https://www.genecards.org/cgi-bin/carddisp.pl?gene=LPL).

```{r}
par(mfrow=c(1,3))
plotCounts(DESeq.ds, gene="GPX2", normalized = TRUE, xlab="")
plotCounts(DESeq.ds, gene="CEBPD", normalized = TRUE, xlab="")
plotCounts(DESeq.ds, gene = which.max(DGE.results$padj), xlab="",
           main = "Gene with max. p.adj.\n(=least significant)")
```

Here we see the normalized counts of three genes between the two conditions. GPX2 is the gene with the min p.adj value, representing the most signifcantly differential expressed gene. CEBPD is a gene we hypothesized would change due to it's involvement in immune cell infiltration, however the results do not show very distinct differential expression between the conditions. The final graph shows the gene with the least significant p-value, therefore showing no difference between the conditions.

#### Volcano Plot

```{r}
#BiocManager::install("EnhancedVolcano")
library(EnhancedVolcano)
vp1 <- EnhancedVolcano(DGE.results,
                       lab=rownames(DGE.results),
                      x='log2FoldChange', y='padj',
                      pCutoff=0.05,
                      title="HIGH / LOW")
print(vp1)
```

The volcano plot allows you to see the log2 fold change of the gene expression between the two experimental conditions is plotted on the x-axis, which measures the magnitude of the difference in expression between the two conditions. The -log10 p-value of the statistical test is plotted on the y-axis, representing the statistical significance of the difference in expression. In this plot, we see a lot of genes having large log fold changes, however the significance of the expression of these genes is not very high.

#### MA Plot
```{r}
plotMA(DGE.results, alpha=0.05,
      main="Test: p.adj.value < 0.05", ylim = c(-8,8))
```

In the MA plot, each point represents a single gene, and the x axis shows the mean normalized counts for that gene, and the y axis represents the log fold change of that gene. Genes that are passing the significance threshold (the adjusted p-value is < 0.05 for this experiment) are colored in blue. The differentially expressed genes increase as you increase the expression. Although, there is higher log fold change of genes at lower expression levels.

#### PCA Plot
```{r}
library(ggplot2)
#pca_data <- plotPCA(rlog(DESeq.ds), intgroup="condition", returnData=TRUE)
plotPCA(rlog(DESeq.ds), intgroup="condition") + geom_text(aes(label = colnames(DESeq.ds)), size = 3, hjust = 0, vjust = 0)
```

The PCA plot shows the reduces dimensionality of the dataset, while preserving the majority of the variation in the data. PC1 accounts for 47% of the variance in the dataset, and based on this, the LOW and the HIGH groups seem generally separated, however they are not totally distinct. LOW_3 and HIGH_3 seem to be overlapping in PC1, but separated heavily in PC2. In PC2, HIGH_2 is somewhat of an outlier, as it doesn't group with the other HIGH condition samples. There isn't drastic differences in these groups, and the clustering in the PCA isn't very promising. However, this could be due primarily to the variability of the disease.

#### Heatmap of DEG sorted by the adjusted p-values.
```{r}
# BiocManager::install("pheatmap")
library(pheatmap)
# identify genes with the desired adjusted p-value cut-off of 0.05
DGEgenes <- rownames(subset(DGE.results.sorted, padj < 0.05)) # extract rlog-transformed values into a matrix
rlog.dge <- DESeq.rlog[DGEgenes,] %>% assay
# Heatmap of DEG sorted by p.adjust
#pheatmap(rlog.dge, scale="none",
#         show_rownames=FALSE, main="DGE (no scaling)",
#         color=colorRampPalette(RColorBrewer::brewer.pal(n=7, name="Reds"))(100)
#)
pheatmap(rlog.dge, scale="row",
         show_rownames=FALSE, main="DGE (row-based z-score)")
```

This heat map can be used to visualize the distribution and relative intensity of the z-scores for each gene for each replicate within each condition. The z-score tells us how many standard deviations the particular point is from the mean of the dataset. Here, each row represents a gene in each sample, and it's z-score. The trend shown here is that the top portion of the genes are down-regulated, and therefore have negative z-scores and are lower expression than the mean, for the HIGH condition samples, they are up-regulated for the LOW condition samples. The opposite can be said for the bottom portion of the genes. Based on this information, HIGH_2 seems to express some genes considerably more or less than the replicates. HIGH_3 seems to not express as much as the other samples within it's condition are. I believe the variability of the disease can cause these variations, but perhaps if we had more data, we could exclude certain samples as outliers.

### 8. Create DGE results table
```{r}
#write.table(subset(DGE.results, padj < 0.05),
#            file="DESeq2results_WT-vs-SNF2.txt",
#            sep="\t", quote=FALSE, row.names=FALSE)
```

### 9. GSEA/Pathway Analysis using Cluster Profiler
```{r}
library(magrittr)
library(dplyr)
#load("/Users/johnmorris/Desktop/Comp_Bio_MS_Weill_Cornell/Spring_2023/ANGSD/Project_Download/ANGSD_NAFLD_Project_2023/Datasets/NAFLD_BulkRNA.RData")

# Constructing a named vector of 0 (= not DE) and 1 (= DEG) 
# Two options - to filter by padj by itself, or by the padj and the abs(log2FoldChange)

#DGE.genes <- rownames(subset(DGE.results.sorted, padj < 0.05))
DGE.genes <- rownames(subset(DGE.results.sorted, padj < 0.05 & abs(log2FoldChange) >= 1.0 ))

gene.vector <- row.names(DGE.results.sorted) %in% DGE.genes %>% as.integer
names(gene.vector) <- row.names(DGE.results.sorted)

# Confirming that there are 1905 genes that have differential expression when using:
length(which(DGE.results$padj < 0.05))

# Confirming that there are 795 genes that have differential expression when using:
length(rownames(subset(DGE.results.sorted, padj < 0.05 & abs(log2FoldChange) >= 1.0)))

# Depending on which one you chose (comment out or comment in DGE.genes code from above), this will change:
length(which(gene.vector ==1))
```

#### Create Table of Differential Expressed Genes from DESeq results

```{r}
DGE_table <- subset(DGE.results.sorted, padj < 0.05 & abs(log2FoldChange) >= 1.0 )
write.table(DGE_table,
    file = "NAFLD_DGE_Table.txt",
    quote = FALSE, row.names = TRUE, col.names = TRUE)
```
subset(DGE.results.sorted, padj < 0.05 & abs(log2FoldChange) >= 1.0 )

```{r,warning=FALSE,message=FALSE}
# Using ClusterProfiler for GSEA 
#BiocManager::install("clusterProfiler")
#BiocManager::install("org.Hs.eg.db")
##BiocManager::install("AnnotationDbi")
#BiocManager::install("TxDb.Hsapiens.UCSC.hg38.knownGene")
#BiocManager::install("TxDb.Hsapiens.UCSC.hg19.knownGene")
library(clusterProfiler)
library(org.Hs.eg.db)
library(AnnotationDbi)
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
```

```{r}
# FOR KEGG ENRICHMENT # https://www.genome.jp/kegg/catalog/org_list.html
# Convert SYMBOLS in gene.vector to UNIPROT_IDs for enrichKEGG function compatability - 4.01% failed to map

# Use mapIds to convert the SYMBOLs where gene.vector == 1 (where ()) to UNIPROT
uniprot_ids_1 <- mapIds(org.Hs.eg.db, keys = names(which(gene.vector == 1)), column = "UNIPROT", keytype = "SYMBOL")

# Use the enrichKEGG to find the KEGG pathways where the uniprot genes are 
kegg_enrichment <- enrichKEGG(gene = uniprot_ids_1, organism = "hsa", keyType = "uniprot")

# view the top 10 enriched kegg pathways
head(kegg_enrichment@result$Description, n = 10)

# FOR GO_ENRICHMENT
BP_go_enrichment <- enrichGO(gene = names(which(gene.vector ==1)), 
                          'org.Hs.eg.db', 
                          keyType = "SYMBOL", # ENTREZ ID NOT SUPPORTED
                          ont = "BP", 
                          pvalueCutoff = 0.01, 
                          qvalueCutoff = 0.05)

head(BP_go_enrichment@result$Description, n = 10)

MF_go_enrichment <- enrichGO(gene = names(which(gene.vector ==1)), 
                          'org.Hs.eg.db', 
                          keyType = "SYMBOL", # ENTREZ ID NOT SUPPORTED
                          ont = "MF", 
                          pvalueCutoff = 0.01, 
                          qvalueCutoff = 0.05)

head(MF_go_enrichment@result$Description, n = 10)

CC_go_enrichment <- enrichGO(gene = names(which(gene.vector ==1)), 
                          'org.Hs.eg.db', 
                          keyType = "SYMBOL", # ENTREZ ID NOT SUPPORTED
                          ont = "CC", 
                          pvalueCutoff = 0.01, 
                          qvalueCutoff = 0.05)

head(CC_go_enrichment@result$Description, n = 10)
```

#### Create GO table

```{r}
#write.table(kegg_enrichment[, c("Description", "pvalue", "p.adjust", "geneID")],
#    file = "Enriched_KEGGterms_NAFLD.txt",
#    quote = FALSE, row.names = FALSE, col.names = TRUE)

#write.table(BP_go_enrichment[, c("Description", "pvalue", "p.adjust", "geneID")],
#    file = "Enriched_BPterms_NAFLD.txt",
#    quote = FALSE, row.names = FALSE, col.names = TRUE)
```

```{r}
# Hypothesis:
# Immune cell infiltration genes in NAFLD
immune_cell_genes <- c("CEBPD", "H4C11", "CEBPB", "GATA3", "KLF4")

# Redox reactions - Metabolic function genes in NAFLD
redox_genes <- c("CAT", "ALDH2", "ALDH8A1")

print("Are the immune cell infiltration genes expressed differentially?")
for (i in immune_cell_genes) {
  if (i %in% names(which(gene.vector == 1))) {
   print(paste(i, TRUE, paste0("Index = ",which(names(gene.vector) == i)) ))
  } else {
    print(paste(i, FALSE))
  }
}

print("Are the redox reaction - metabolic function genes expressed differentially?")
for (i in redox_genes) {
  if (i %in% names(which(gene.vector == 1))) {
   print(paste(i, TRUE, paste0("Index = ",which(names(gene.vector) == i)) ))
  } else {
    print(paste(i, FALSE))
  }
}
```

# V. Citations:

1. Angulo, P., Kleiner, D. E., Dam-Larsen, S., Adams, L. A., Bjornsson, E. S., Charatcharoenwitthaya, P., Mills, P. R., Keach, J. C., Lafferty, H. D., Stahler, A., Haflidadottir, S., & Bendtsen, F. (2015). Liver fibrosis, but no other histologic features, is associated with long-term outcomes of patients with nonalcoholic fatty liver disease. Gastroenterology, 149(2), 389-397.e10. https://doi.org/10.1053/j.gastro.2015.04.043

2. Cao, Y., Du, Y., Jia, W., Ding, J., Yuan, J., Zhang, H., Zhang, X., Tao, K., & Yang, Z. (2023). Identification of biomarkers for the diagnosis of chronic kidney disease (CKD) with non-alcoholic fatty liver disease (NAFLD) by bioinformatics analysis and machine learning. Frontiers in Endocrinology, 14, 1125829. https://doi.org/10.3389/fendo.2023.1125829

3. Estes, C., Razavi, H., Loomba, R., Younossi, Z., & Sanyal, A. J. (2018). Modeling the epidemic of nonalcoholic fatty liver disease demonstrates an exponential increase in burden of disease: Estes et al. Hepatology (Baltimore, Md.), 67(1), 123–133. https://doi.org/10.1002/hep.29466

4. Han, N., He, J., Shi, L., Zhang, M., Zheng, J., & Fan, Y. (2022). Identification of biomarkers in nonalcoholic fatty liver disease: A machine learning method and experimental study. Frontiers in Genetics, 13, 1020899. https://doi.org/10.3389/fgene.2022.1020899

5. Hoang, S. A., Oseini, A., Feaver, R. E., Cole, B. K., Asgharpour, A., Vincent, R., Siddiqui, M., Lawson, M. J., Day, N. C., Taylor, J. M., Wamhoff, B. R., Mirshahi, F., Contos, M. J., Idowu, M., & Sanyal, A. J. (2019). Gene expression predicts histological severity and reveals distinct molecular profiles of nonalcoholic fatty liver disease. Scientific Reports, 9(1), 12541. https://doi.org/10.1038/s41598-019-48746-5

6. Moylan, C. A., Pang, H., Dellinger, A., Suzuki, A., Garrett, M. E., Guy, C. D., Murphy, S. K., Ashley-Koch, A. E., Choi, S. S., Michelotti, G. A., Hampton, D. D., Chen, Y., Tillmann, H. L., Hauser, M. A., Abdelmalek, M. F., & Diehl, A. M. (2014). Hepatic gene expression profiles differentiate presymptomatic patients with mild versus severe nonalcoholic fatty liver disease: Hepatology. Hepatology (Baltimore, Md.), 59(2), 471–482. https://doi.org/10.1002/hep.26661

7. Rivera, W. (2022, May 23). Nonalcoholic Fatty Liver Disease (NAFLD). American Liver Foundation. https://liverfoundation.org/liver-diseases/fatty-liver-disease/nonalcoholic-fatty-liver-disease-nafld/

8. Suppli, M. P., Rigbolt, K. T. G., Veidal, S. S., Heebøll, S., Eriksen, P. L., Demant, M., Bagger, J. I., Nielsen, J. C., Oró, D., Thrane, S. W., Lund, A., Strandberg, C., Kønig, M. J., Vilsbøll, T., Vrang, N., Thomsen, K. L., Grønbæk, H., Jelsing, J., Hansen, H. H., & Knop, F. K. (2019). Hepatic transcriptome signatures in patients with varying degrees of nonalcoholic fatty liver disease compared with healthy normal-weight individuals. American Journal of Physiology. Gastrointestinal and Liver Physiology, 316(4), G462–G472. https://doi.org/10.1152/ajpgi.00358.2018

9. Taylor, R. S., Taylor, R. J., Bayliss, S., Hagström, H., Nasr, P., Schattenberg, J. M., Ishigami, M., Toyoda, H., Wai-Sun Wong, V., Peleg, N., Shlomai, A., Sebastiani, G., Seko, Y., Bhala, N., Younossi, Z. M., Anstee, Q. M., McPherson, S., & Newsome, P. N. (2020). Association between fibrosis stage and outcomes of patients with nonalcoholic fatty liver disease: A systematic review and meta-analysis. Gastroenterology, 158(6), 1611-1625.e12. https://doi.org/10.1053/j.gastro.2020.01.043

10. Tilg, H., & Moschen, A. R. (2010). Evolution of inflammation in nonalcoholic fatty liver disease: the multiple parallel hits hypothesis. Hepatology (Baltimore, Md.), 52(5), 1836–1846. https://doi.org/10.1002/hep.24001

11. Younossi, Z. M., Blissett, D., Blissett, R., Henry, L., Stepanova, M., Younossi, Y., Racila, A., Hunt, S., & Beckerman, R. (2016). The economic and clinical burden of nonalcoholic fatty liver disease in the United States and Europe. Hepatology (Baltimore, Md.), 64(5), 1577–1586. https://doi.org/10.1002/hep.28785
